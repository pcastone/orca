//! CompiledGraph execution engine for running stateful workflows
//!
//! This module provides the execution runtime for compiled graphs. Once a graph is built
//! using [`StateGraph`](crate::StateGraph) and compiled, it becomes a [`CompiledGraph`]
//! that can be executed multiple times with different inputs, providing deterministic,
//! checkpointed, and observable execution.
//!
//! # Overview
//!
//! `CompiledGraph` is the runtime execution engine that takes a graph definition and runs it
//! using a Pregel-inspired model. It provides:
//!
//! - **Deterministic Execution** - Same input + checkpoint = same output
//! - **Parallel Processing** - Independent nodes run concurrently
//! - **State Persistence** - Automatic checkpointing at each step
//! - **Real-time Streaming** - 7 streaming modes for observability
//! - **Human-in-the-Loop** - Pause/resume with interrupts
//! - **Time Travel** - Resume from any historical checkpoint
//!
//! # Architecture
//!
//! ```text
//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//! ‚îÇ  CompiledGraph Execution Model                              ‚îÇ
//! ‚îÇ                                                              ‚îÇ
//! ‚îÇ  Input State                                                 ‚îÇ
//! ‚îÇ       ‚Üì                                                      ‚îÇ
//! ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
//! ‚îÇ  ‚îÇ  Superstep 0                                 ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Read channels (initial state)             ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Execute entry nodes (parallel)            ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Write channel updates                     ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Barrier (wait for all)                    ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Checkpoint                                ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
//! ‚îÇ       ‚Üì                                                      ‚îÇ
//! ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
//! ‚îÇ  ‚îÇ  Superstep 1                                 ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Read updated channels                     ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Execute triggered nodes (parallel)        ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Write updates                             ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Barrier                                   ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îÇ  ‚Ä¢ Checkpoint                                ‚îÇ           ‚îÇ
//! ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
//! ‚îÇ       ‚Üì                                                      ‚îÇ
//! ‚îÇ    [Continue until END or interrupt]                        ‚îÇ
//! ‚îÇ       ‚Üì                                                      ‚îÇ
//! ‚îÇ  Final State                                                ‚îÇ
//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//! ```
//!
//! # Key Types
//!
//! - [`CompiledGraph`] - The executable graph runtime
//! - [`ExecutionEvent`] - Legacy execution events
//! - [`StreamChunk`](crate::stream::StreamChunk) - Modern streaming events
//! - [`EventStream`] - Async stream of execution events
//! - [`StreamChunkStream`] - Stream of state/debug chunks
//!
//! # Execution Modes
//!
//! ## Invoke - One-Shot Execution
//!
//! Run the graph to completion and return final state:
//!
//! ```rust,ignore
//! use langgraph_core::StateGraph;
//! use serde_json::json;
//!
//! let mut graph = StateGraph::new();
//! // ... add nodes and edges ...
//! let compiled = graph.compile()?;
//!
//! let result = compiled.invoke(json!({"input": "data"})).await?;
//! println!("Final state: {:?}", result);
//! ```
//!
//! ## Stream - Real-Time Updates
//!
//! Stream execution events in real-time using 7 different modes:
//!
//! ```rust,ignore
//! use langgraph_core::stream::StreamMode;
//! use futures::StreamExt;
//!
//! // Stream with default Values mode (complete state after each step)
//! let mut stream = compiled.stream(json!({"input": "data"})).await?;
//!
//! while let Some(event) = stream.next().await {
//!     match event {
//!         ExecutionEvent::StateUpdate { state } => {
//!             println!("State: {:?}", state);
//!         }
//!         _ => {}
//!     }
//! }
//! ```
//!
//! ## Stream with Multiple Modes
//!
//! Observe execution at different granularities simultaneously:
//!
//! ```rust,ignore
//! use langgraph_core::stream::StreamMode;
//! use futures::StreamExt;
//!
//! let mut stream = compiled.stream_chunks_with_modes(
//!     json!({"input": "data"}),
//!     vec![StreamMode::Values, StreamMode::Updates, StreamMode::Debug],
//!     None,
//! ).await?;
//!
//! while let Some(chunk) = stream.next().await {
//!     match chunk.mode {
//!         StreamMode::Values => println!("Complete state: {:?}", chunk.event),
//!         StreamMode::Updates => println!("Node update: {:?}", chunk.event),
//!         StreamMode::Debug => println!("Debug info: {:?}", chunk.event),
//!         _ => {}
//!     }
//! }
//! ```
//!
//! # Checkpointing
//!
//! ## Basic Checkpointing
//!
//! Enable state persistence and recovery:
//!
//! ```rust,ignore
//! use langgraph_checkpoint::{InMemoryCheckpointSaver, CheckpointConfig};
//! use std::sync::Arc;
//!
//! let checkpointer = Arc::new(InMemoryCheckpointSaver::new());
//! let compiled = graph.compile()?.with_checkpointer(checkpointer);
//!
//! let config = CheckpointConfig::new()
//!     .with_thread_id("session-123".to_string());
//!
//! let result = compiled.invoke_with_config(
//!     json!({"input": "data"}),
//!     Some(config),
//! ).await?;
//! ```
//!
//! ## Resume from Checkpoint
//!
//! Continue execution from a saved state:
//!
//! ```rust,ignore
//! // Get checkpoint history
//! let history = compiled.get_state_history(
//!     CheckpointConfig::new().with_thread_id("session-123".to_string())
//! ).await?;
//!
//! // Resume from specific checkpoint
//! let resume_config = CheckpointConfig::new()
//!     .with_thread_id("session-123".to_string())
//!     .with_checkpoint_id(history[0].config.checkpoint_id.clone());
//!
//! let result = compiled.invoke_with_config(
//!     json!({"new_input": "data"}),
//!     Some(resume_config),
//! ).await?;
//! ```
//!
//! ## Update State at Checkpoint
//!
//! Modify state before resuming:
//!
//! ```rust,ignore
//! // Update state at current checkpoint
//! compiled.update_state(
//!     config.clone(),
//!     json!({"corrected_value": 42}),
//!     None, // as_node: apply as if coming from this node
//! ).await?;
//!
//! // Resume with updated state
//! let result = compiled.invoke_with_config(json!({}), Some(config)).await?;
//! ```
//!
//! # Common Patterns
//!
//! ## Conversational Agent with History
//!
//! Build a stateful chat agent:
//!
//! ```rust,ignore
//! use langgraph_core::messages::Message;
//!
//! let compiled = build_chat_graph().compile()?
//!     .with_checkpointer(checkpointer);
//!
//! // User conversation session
//! let config = CheckpointConfig::new()
//!     .with_thread_id("user-session-456".to_string());
//!
//! // First message
//! let result = compiled.invoke_with_config(
//!     json!({"messages": [Message::human("Hello!")]}),
//!     Some(config.clone()),
//! ).await?;
//!
//! // Continuation (loads previous state automatically)
//! let result = compiled.invoke_with_config(
//!     json!({"messages": [Message::human("Tell me more")]}),
//!     Some(config),
//! ).await?;
//! ```
//!
//! ## Approval Workflows
//!
//! Pause for human approval:
//!
//! ```rust,ignore
//! use langgraph_core::error::GraphError;
//!
//! loop {
//!     match compiled.invoke_with_config(input.clone(), Some(config.clone())).await {
//!         Ok(result) => {
//!             println!("Workflow complete: {:?}", result);
//!             break;
//!         }
//!         Err(GraphError::Interrupted { node, reason }) => {
//!             println!("Paused at {}: {}", node, reason);
//!
//!             // Get user approval
//!             let approved = get_approval().await;
//!
//!             // Update state with approval
//!             compiled.update_state(
//!                 config.clone(),
//!                 json!({"approved": approved}),
//!                 None,
//!             ).await?;
//!
//!             // Continue (will resume from interrupt)
//!             continue;
//!         }
//!         Err(e) => return Err(e),
//!     }
//! }
//! ```
//!
//! ## Parallel Processing with Fanout
//!
//! Process items in parallel then aggregate:
//!
//! ```rust,ignore
//! use langgraph_core::Send;
//!
//! // Graph with fanout node
//! graph.add_conditional_edge("fanout", |state| {
//!     let items = state["items"].as_array().unwrap();
//!     items.iter().map(|item| {
//!         Send::new("process", json!({"item": item}))
//!     }).collect()
//! });
//!
//! let compiled = graph.compile()?;
//! let result = compiled.invoke(json!({"items": [1, 2, 3, 4, 5]})).await?;
//! ```
//!
//! ## Streaming LLM Responses
//!
//! Stream token-by-token from language models:
//!
//! ```rust,ignore
//! use langgraph_core::stream::StreamMode;
//!
//! let mut stream = compiled.stream_chunks_with_modes(
//!     json!({"prompt": "Write a story"}),
//!     vec![StreamMode::Messages],
//!     None,
//! ).await?;
//!
//! while let Some(chunk) = stream.next().await {
//!     if let StreamEvent::MessageChunk { chunk: token, .. } = chunk.event {
//!         print!("{}", token); // Print as tokens arrive
//!         std::io::stdout().flush().ok();
//!     }
//! }
//! ```
//!
//! # Advanced Features
//!
//! ## Custom Checkpointers
//!
//! Implement persistent storage:
//!
//! ```rust,ignore
//! use langgraph_checkpoint::CheckpointSaver;
//!
//! // Use PostgreSQL, SQLite, Redis, etc.
//! let checkpointer = Arc::new(PostgresCheckpointSaver::new(pool));
//! let compiled = graph.compile()?.with_checkpointer(checkpointer);
//! ```
//!
//! ## State Inspection
//!
//! Query current state without execution:
//!
//! ```rust,ignore
//! let state_snapshot = compiled.get_state(config).await?;
//! println!("Current state: {:?}", state_snapshot.values);
//! println!("Next nodes: {:?}", state_snapshot.next);
//! ```
//!
//! ## Visualization
//!
//! Generate graph diagrams:
//!
//! ```rust,ignore
//! let mermaid = compiled.visualize()?;
//! println!("{}", mermaid); // Display in Mermaid-compatible viewer
//! ```
//!
//! # Performance Tuning
//!
//! ## Parallelism
//!
//! - **Independent nodes** execute concurrently within each superstep
//! - Controlled by Tokio runtime (set `TOKIO_WORKER_THREADS`)
//! - Barrier synchronization between supersteps ensures correctness
//!
//! ## Checkpointing Overhead
//!
//! - Checkpoint saved **after each superstep** (automatic)
//! - For high-throughput, use batched checkpoint savers
//! - In-memory checkpointer is fastest but non-persistent
//! - Consider checkpoint frequency vs recovery granularity tradeoff
//!
//! ## Streaming Performance
//!
//! - Bounded channels prevent memory overflow (100 item buffer)
//! - Choose minimal streaming modes needed
//! - `Updates` mode is most efficient (only deltas)
//! - `Debug` mode has higher overhead (tasks + checkpoints)
//!
//! ## State Size
//!
//! - Keep state minimal - avoid large embedded data
//! - Use [`Store`](crate::store) for large persistent data
//! - Consider pagination for large lists
//! - Prune message history with [`trim_messages`](crate::messages::trim_messages)
//!
//! # Error Handling
//!
//! ## Error Types
//!
//! All errors wrapped in [`GraphError`](crate::error::GraphError):
//!
//! - **NodeExecution** - Node threw an error
//! - **Interrupted** - Human-in-the-loop pause (not a failure!)
//! - **Checkpoint** - Failed to save/load state
//! - **StateError** - Invalid state structure
//! - **Validation** - Graph structure invalid
//!
//! ## Handling Interrupts
//!
//! Interrupts are **expected flow**, not errors:
//!
//! ```rust,ignore
//! match compiled.invoke_with_config(input, Some(config)).await {
//!     Ok(result) => handle_completion(result),
//!     Err(GraphError::Interrupted { node, reason }) => {
//!         // Expected - collect user input and resume
//!         handle_interrupt(node, reason).await
//!     }
//!     Err(e) => handle_error(e), // Actual error
//! }
//! ```
//!
//! # Comparison with Python LangGraph
//!
//! | Python LangGraph | rLangGraph | Notes |
//! |------------------|------------|-------|
//! | `graph.invoke(input)` | `compiled.invoke(input).await?` | Async in Rust |
//! | `graph.stream(input)` | `compiled.stream(input).await?` | Returns Stream |
//! | `graph.get_state(config)` | `compiled.get_state(config).await?` | Async |
//! | `graph.update_state(config, values)` | `compiled.update_state(config, values, None).await?` | Async |
//! | `checkpointer=saver` | `.with_checkpointer(saver)` | Fluent builder |
//! | `config={"configurable": {...}}` | `CheckpointConfig::new().with_thread_id(...)` | Type-safe config |
//!
//! # See Also
//!
//! - [`StateGraph`](crate::StateGraph) - Building graphs
//! - [`stream`](crate::stream) - Streaming system details
//! - [`error`](crate::error) - Error types and handling
//! - [`CheckpointSaver`](langgraph_checkpoint::CheckpointSaver) - Checkpoint backends
//! - [`pregel`](crate::pregel) - Execution engine internals

use crate::error::{GraphError, Result};
use crate::graph::{Edge, Graph, NodeExecutor as GraphNodeExecutor, NodeId, SubgraphExecutor, END, START, TASKS};
use crate::interrupt::{InterruptConfig, InterruptWhen};
use crate::pregel::{
    Checkpoint as PregelCheckpoint, ChannelVersion, LastValueChannel, NodeExecutor,
    PregelLoop, PregelNodeSpec,
};
use crate::stream::{StreamChunk, StreamMode};
use langgraph_checkpoint::{BinaryOperatorChannel, TopicChannel};
use futures::stream::{Stream, StreamExt};
use langgraph_checkpoint::{
    Channel, CheckpointConfig, CheckpointMetadata, CheckpointSaver, CheckpointTuple,
};
use serde_json::Value;
use std::collections::HashMap;
use std::pin::Pin;
use std::sync::Arc;

/// Events emitted during graph execution (legacy streaming API).
///
/// These events provide observability into graph execution and were used
/// with the deprecated `stream_with_modes()` API. For new code, prefer the
/// [`StreamChunk`](crate::stream::StreamChunk) API with `stream_chunks_with_modes()`.
///
/// # Event Types and Lifecycle
///
/// Events are emitted in a specific order during execution:
///
/// ```text
/// NodeStart ‚Üí NodeEnd/Error ‚Üí StateUpdate ‚Üí ... ‚Üí Complete/Interrupted
/// ```
///
/// # Variants
///
/// ## NodeStart
///
/// Emitted when a node begins execution. Useful for:
/// - Progress tracking
/// - Performance monitoring (start time)
/// - Debug logging
///
/// ## NodeEnd
///
/// Emitted when a node completes successfully. Contains:
/// - Node name
/// - Output value produced by the node
///
/// Use for:
/// - Collecting intermediate results
/// - Monitoring successful completions
/// - Updating UI with partial results
///
/// ## StateUpdate
///
/// Emitted after state changes are applied. Contains the complete
/// current state. This is the most commonly used event for:
/// - Displaying current state to users
/// - State persistence
/// - React/UI updates
///
/// ## Error
///
/// Emitted when a node fails. Contains:
/// - Node that failed
/// - Error message
///
/// Use for:
/// - Error handling
/// - Retry logic
/// - User notifications
///
/// ## Interrupted
///
/// Emitted when execution pauses for human input. Contains:
/// - Node where interrupt occurred
/// - When (before/after node execution)
/// - Current state at interrupt point
///
/// Use for:
/// - Human-in-the-loop workflows
/// - Approval gates
/// - Manual intervention points
///
/// ## Complete
///
/// Emitted when the graph finishes all execution. Contains
/// the final state. Signals successful completion.
///
/// # Migration Guide
///
/// ## Old API (Deprecated)
///
/// ```rust,ignore
/// use langgraph_core::{StateGraph, ExecutionEvent};
/// use futures::StreamExt;
///
/// let compiled = graph.compile()?;
/// let mut stream = compiled.stream_with_modes(
///     input,
///     vec!["values"],
///     None,
/// ).await?;
///
/// while let Some(event) = stream.next().await {
///     match event {
///         ExecutionEvent::StateUpdate { state } => {
///             println!("State: {:?}", state);
///         }
///         ExecutionEvent::Complete { final_state } => {
///             println!("Done: {:?}", final_state);
///         }
///         _ => {}
///     }
/// }
/// ```
///
/// ## New API (Recommended)
///
/// ```rust,ignore
/// use langgraph_core::{StateGraph, StreamMode};
/// use futures::StreamExt;
///
/// let compiled = graph.compile()?;
/// let mut stream = compiled.stream_chunks_with_modes(
///     input,
///     vec![StreamMode::Values],
///     None,
/// ).await?;
///
/// while let Some(chunk) = stream.next().await {
///     match chunk.event {
///         StreamEvent::Values { values } => {
///             println!("State: {:?}", values);
///         }
///         StreamEvent::Complete => {
///             println!("Done");
///         }
///         _ => {}
///     }
/// }
/// ```
///
/// # Example: Tracking Execution Progress
///
/// ```rust,ignore
/// use langgraph_core::ExecutionEvent;
/// use std::time::Instant;
/// use std::collections::HashMap;
///
/// let mut node_times = HashMap::new();
///
/// for event in events {
///     match event {
///         ExecutionEvent::NodeStart { node } => {
///             node_times.insert(node.clone(), Instant::now());
///             println!("Starting {}", node);
///         }
///         ExecutionEvent::NodeEnd { node, output } => {
///             if let Some(start) = node_times.get(&node) {
///                 println!("{} took {:?}", node, start.elapsed());
///             }
///         }
///         ExecutionEvent::Error { node, error } => {
///             eprintln!("Failed at {}: {}", node, error);
///             // Implement retry logic
///         }
///         _ => {}
///     }
/// }
/// ```
///
/// # See Also
///
/// - [`StreamChunk`](crate::stream::StreamChunk) - New streaming API
/// - [`StreamMode`](crate::stream::StreamMode) - Streaming modes
/// - [`stream_chunks_with_modes`](Self::stream_chunks_with_modes) - New streaming method
#[derive(Debug, Clone)]
pub enum ExecutionEvent {
    /// Node execution started.
    ///
    /// Emitted immediately before a node's executor function is called.
    NodeStart {
        /// Name of the node that started executing
        node: NodeId
    },

    /// Node execution completed successfully.
    ///
    /// Emitted after a node's executor returns Ok(value).
    NodeEnd {
        /// Name of the node that completed
        node: NodeId,
        /// Output value produced by the node
        output: Value
    },

    /// Graph state was updated.
    ///
    /// Emitted after channel writes are applied and state changes.
    /// Contains the complete current state of all channels.
    StateUpdate {
        /// Complete current state across all channels
        state: Value
    },

    /// Node execution failed with error.
    ///
    /// Emitted when a node's executor returns Err.
    Error {
        /// Name of the node that failed
        node: NodeId,
        /// Error message describing the failure
        error: String
    },

    /// Execution was interrupted for human input.
    ///
    /// Emitted when an interrupt condition is triggered.
    /// Execution can be resumed with updated state.
    Interrupted {
        /// Node where the interrupt occurred
        node: NodeId,
        /// Whether interrupt was before or after node execution
        when: InterruptWhen,
        /// Current state at the interrupt point
        state: Value,
    },

    /// Graph execution completed successfully.
    ///
    /// Emitted when no more tasks remain and graph reaches completion.
    Complete {
        /// Final state after all execution
        final_state: Value
    },
}

/// Stream of execution events
pub type EventStream = Pin<Box<dyn Stream<Item = ExecutionEvent> + Send>>;

/// Stream of streaming chunks (new API)
pub type StreamChunkStream = Pin<Box<dyn Stream<Item = StreamChunk> + Send>>;

/// Snapshot of the graph state at a specific point in time.
///
/// Represents a complete view of the graph's execution state, including
/// what has been executed, what will execute next, and all state values.
/// Essential for time-travel debugging, state inspection, and resumption.
///
/// # Structure
///
/// Each snapshot captures:
/// - **values**: Complete state across all channels
/// - **next**: Nodes scheduled for next execution
/// - **config**: Checkpoint configuration (thread_id, checkpoint_id)
/// - **metadata**: Execution metadata (step, source, writes)
/// - **created_at**: ISO 8601 timestamp
/// - **parent_config**: Link to previous snapshot for history traversal
///
/// # Use Cases
///
/// ## Time-Travel Debugging
///
/// ```rust,ignore
/// use langgraph_core::CompiledGraph;
///
/// // Get snapshots for a thread
/// let history = compiled.get_state_history(config).await?;
///
/// // Iterate through execution history
/// while let Some(Ok(snapshot)) = history.next().await {
///     println!("Step: {:?}", snapshot.metadata.as_ref().map(|m| m.step));
///     println!("State: {:?}", snapshot.values);
///     println!("Next: {:?}", snapshot.next);
///
///     // Navigate to parent snapshot
///     if let Some(parent) = snapshot.parent_config {
///         // Load parent state...
///     }
/// }
/// ```
///
/// ## State Inspection
///
/// ```rust,ignore
/// // Get current state
/// let snapshot = compiled.get_state(config).await?;
///
/// // Check what will execute next
/// if snapshot.next.is_empty() {
///     println!("Graph complete");
/// } else {
///     println!("Next nodes: {:?}", snapshot.next);
/// }
///
/// // Inspect specific values
/// if let Some(messages) = snapshot.values.get("messages") {
///     println!("Messages: {:?}", messages);
/// }
/// ```
///
/// ## Resumption from Checkpoint
///
/// ```rust,ignore
/// // Get a historical snapshot
/// let snapshot = compiled.get_state(
///     config.with_checkpoint_id("checkpoint-123")
/// ).await?;
///
/// // Resume from that point
/// let result = compiled.invoke_with_config(
///     snapshot.values,
///     &snapshot.config,
/// ).await?;
/// ```
///
/// # Metadata Fields
///
/// The `metadata` field contains:
/// - **step**: Superstep number (0-based)
/// - **source**: What triggered this checkpoint ("input", "loop", "update")
/// - **writes**: Channel writes that created this checkpoint
/// - **thread_id**: Thread identifier for multi-tenant execution
/// - **checkpoint_ns**: Namespace for subgraph checkpoints
/// - **parent_config**: Previous checkpoint in the chain
///
/// # Example
///
/// ```rust,ignore
/// use langgraph_core::StateSnapshot;
///
/// let snapshot = StateSnapshot {
///     values: json!({"count": 5, "messages": ["Hello"]}),
///     next: vec!["process".to_string()],
///     config: CheckpointConfig::new("thread-1")
///         .with_checkpoint_id("checkpoint-456"),
///     metadata: Some(CheckpointMetadata {
///         step: Some(3),
///         source: Some("loop".to_string()),
///         writes: Some(json!({"process": {"count": 5}})),
///         ..Default::default()
///     }),
///     created_at: Some("2024-01-15T10:30:00Z".to_string()),
///     parent_config: Some(CheckpointConfig::new("thread-1")
///         .with_checkpoint_id("checkpoint-455")),
/// };
///
/// // Check if execution is complete
/// if snapshot.next.is_empty() {
///     println!("Execution complete at step {:?}",
///              snapshot.metadata.as_ref().and_then(|m| m.step));
/// }
/// ```
///
/// # See Also
///
/// - [`get_state`](CompiledGraph::get_state) - Retrieve current snapshot
/// - [`get_state_history`](CompiledGraph::get_state_history) - Get snapshot history
/// - [`update_state`](CompiledGraph::update_state) - Modify state
/// - [`CheckpointConfig`] - Configuration for checkpoints
#[derive(Debug, Clone)]
pub struct StateSnapshot {
    /// Complete current state values across all channels.
    ///
    /// This is a JSON object containing all channel values at the
    /// time of the snapshot. The structure depends on your graph's
    /// state schema.
    pub values: Value,

    /// Names of nodes scheduled to execute next.
    ///
    /// Empty vec indicates graph completion. Nodes listed here
    /// will execute in the next superstep when execution resumes.
    pub next: Vec<String>,

    /// Checkpoint configuration identifying this snapshot.
    ///
    /// Contains thread_id and checkpoint_id. Used to resume
    /// execution from this exact point.
    pub config: CheckpointConfig,

    /// Execution metadata for this snapshot.
    ///
    /// Contains step number, source, writes, and other execution
    /// context. May be None for manually created snapshots.
    pub metadata: Option<CheckpointMetadata>,

    /// Timestamp when this snapshot was created (ISO 8601 format).
    ///
    /// Example: "2024-01-15T10:30:00Z"
    pub created_at: Option<String>,

    /// Configuration of the parent snapshot for history traversal.
    ///
    /// Links to the previous checkpoint in the execution chain.
    /// None for the initial checkpoint.
    pub parent_config: Option<CheckpointConfig>,
}

/// Stream of state snapshots for history traversal
pub type StateSnapshotStream = Pin<Box<dyn Stream<Item = Result<StateSnapshot>> + Send>>;

/// Compiled graph ready for execution
#[derive(Clone)]
pub struct CompiledGraph {
    pub(crate) graph: Graph,
    checkpoint_saver: Option<Arc<dyn CheckpointSaver>>,
    interrupt_config: InterruptConfig,
    store: Option<Arc<dyn crate::store::Store>>,
}

impl CompiledGraph {
    /// Create a new compiled graph
    pub(crate) fn new(graph: Graph) -> Result<Self> {
        Ok(Self {
            graph,
            checkpoint_saver: None,
            interrupt_config: InterruptConfig::default(),
            store: None,
        })
    }

    /// Create a new compiled graph with interrupt configuration
    pub(crate) fn new_with_interrupts(graph: Graph, interrupt_config: InterruptConfig) -> Result<Self> {
        Ok(Self {
            graph,
            checkpoint_saver: None,
            interrupt_config,
            store: None,
        })
    }

    /// Set the checkpoint saver
    pub fn with_checkpointer(mut self, saver: Arc<dyn CheckpointSaver>) -> Self {
        self.checkpoint_saver = Some(saver);
        self
    }

    /// Set the store for persistent state access
    pub fn with_store(mut self, store: Arc<dyn crate::store::Store>) -> Self {
        self.store = Some(store);
        self
    }

    /// Visualize the graph structure
    ///
    /// Returns a string representation of the graph in the specified format.
    ///
    /// # Arguments
    ///
    /// * `options` - Visualization options (format, details, etc.)
    ///
    /// # Returns
    ///
    /// String containing the graph visualization
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, VisualizationOptions};
    ///
    /// let mut graph = StateGraph::new();
    /// graph.add_node("process", |state| {
    ///     Box::pin(async move { Ok(state) })
    /// });
    /// graph.add_edge("__start__", "process");
    /// graph.add_edge("process", "__end__");
    ///
    /// let compiled = graph.compile().unwrap();
    ///
    /// // Generate DOT format
    /// let dot = compiled.visualize(&VisualizationOptions::dot());
    /// println!("{}", dot);
    ///
    /// // Generate Mermaid format
    /// let mermaid = compiled.visualize(&VisualizationOptions::mermaid());
    /// println!("{}", mermaid);
    /// ```
    pub fn visualize(&self, options: &crate::visualization::VisualizationOptions) -> String {
        crate::visualization::visualize(&self.graph, options)
    }

    /// Retrieve the current state at a specific checkpoint.
    ///
    /// This method provides **read-only access** to the graph's state at any checkpoint,
    /// enabling debugging, monitoring, and state inspection without modifying execution.
    ///
    /// # Architecture
    ///
    /// ```text
    /// CheckpointConfig
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ   Saver      ‚îÇ
    /// ‚îÇ  get_tuple() ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ  Transform   ‚îÇ
    /// ‚îÇ to Snapshot  ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ
    ///        ‚ñº
    ///  StateSnapshot
    /// ‚îú‚îÄ‚îÄ values: State data
    /// ‚îú‚îÄ‚îÄ next: Tasks to run
    /// ‚îú‚îÄ‚îÄ tasks: Current tasks
    /// ‚îî‚îÄ‚îÄ metadata: Checkpoint info
    /// ```
    ///
    /// # Arguments
    ///
    /// * `config` - Checkpoint configuration specifying which state to retrieve:
    ///   - `thread_id` - Required thread identifier
    ///   - `checkpoint_ns` - Optional namespace for sub-checkpoints
    ///   - `checkpoint_id` - Optional specific checkpoint version
    ///
    /// # Returns
    ///
    /// - `Some(StateSnapshot)` - Complete state at the checkpoint if found
    /// - `None` - If checkpoint doesn't exist or no saver configured
    ///
    /// # Example: Debugging Current State
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, CheckpointConfig};
    /// use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// use std::sync::Arc;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// graph.add_node("agent", |state| {
    ///     Box::pin(async move {
    ///         // Complex processing
    ///         Ok(state)
    ///     })
    /// });
    /// graph.add_edge("__start__", "agent");
    /// graph.add_edge("agent", "__end__");
    ///
    /// let saver = Arc::new(InMemoryCheckpointSaver::new());
    /// let compiled = graph.compile()?.with_checkpointer(saver);
    ///
    /// // Execute graph
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("debug-session")
    ///     .build();
    /// compiled.invoke_with_config(
    ///     serde_json::json!({"input": "test"}),
    ///     config.clone()
    /// ).await?;
    ///
    /// // Inspect final state
    /// if let Some(snapshot) = compiled.get_state(&config).await? {
    ///     println!("üìä Final state values: {:#?}", snapshot.values);
    ///     println!("‚è≠Ô∏è Next tasks to run: {:?}", snapshot.next);
    ///     println!("üìÖ Created at: {:?}", snapshot.created_at);
    ///
    ///     // Check for errors
    ///     if let Some(errors) = snapshot.values.get("errors") {
    ///         println!("‚ùå Errors found: {:#?}", errors);
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Monitoring Multi-Agent Conversation
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use std::sync::Arc;
    /// # use serde_json::json;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("conversation-456")
    ///     .build();
    ///
    /// // Check state after each turn
    /// for turn in 1..=3 {
    ///     // Execute turn
    ///     compiled.invoke_with_config(
    ///         json!({"message": format!("Turn {}", turn)}),
    ///         config.clone()
    ///     ).await?;
    ///
    ///     // Inspect state
    ///     if let Some(snapshot) = compiled.get_state(&config).await? {
    ///         if let Some(messages) = snapshot.values.get("messages") {
    ///             println!("Turn {} messages: {}", turn, messages.as_array().unwrap().len());
    ///         }
    ///
    ///         // Check if conversation is complete
    ///         if snapshot.next.is_empty() {
    ///             println!("Conversation complete at turn {}", turn);
    ///             break;
    ///         }
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Retrieving Specific Checkpoint Version
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{CheckpointConfig};
    /// # use langgraph_core::StateGraph;
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use std::sync::Arc;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// // Get state at specific checkpoint
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("workflow-789")
    ///     .with_checkpoint_id("checkpoint_abc123")  // Specific version
    ///     .build();
    ///
    /// if let Some(snapshot) = compiled.get_state(&config).await? {
    ///     println!("State at checkpoint abc123: {:#?}", snapshot.values);
    ///
    ///     // Access parent checkpoint for comparison
    ///     if let Some(parent_id) = &snapshot.parent_config {
    ///         let parent_config = CheckpointConfig::builder()
    ///             .with_thread_id("workflow-789")
    ///             .with_checkpoint_id(parent_id.checkpoint_id.clone().unwrap())
    ///             .build();
    ///
    ///         if let Some(parent_snapshot) = compiled.get_state(&parent_config).await? {
    ///             println!("Parent state: {:#?}", parent_snapshot.values);
    ///         }
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Use Cases
    ///
    /// 1. **Debugging**: Inspect state when errors occur
    /// 2. **Monitoring**: Track progress of long-running workflows
    /// 3. **Analytics**: Analyze state evolution over time
    /// 4. **Testing**: Verify state correctness at checkpoints
    /// 5. **Recovery**: Understand state before resuming from interrupts
    ///
    /// # Performance Notes
    ///
    /// - Returns immediately if no checkpoint saver configured
    /// - Single checkpoint lookup (no history traversal)
    /// - State is cloned (original checkpoint unmodified)
    /// - Thread-safe for concurrent reads
    ///
    /// # See Also
    ///
    /// - [`get_state_history`](Self::get_state_history) - Retrieve multiple checkpoints
    /// - [`update_state`](Self::update_state) - Modify checkpoint state
    /// - [`StateSnapshot`] - Structure of returned state data
    /// - [`invoke_with_config`](Self::invoke_with_config) - Resume from checkpoint
    pub async fn get_state(&self, config: &CheckpointConfig) -> Result<Option<StateSnapshot>> {
        let Some(saver) = &self.checkpoint_saver else {
            return Ok(None);
        };

        let tuple = saver.get_tuple(config).await
            .map_err(|e| GraphError::Checkpoint(e))?;

        Ok(tuple.map(|t| self.checkpoint_tuple_to_snapshot(t)))
    }

    /// Traverse the complete execution history of a graph thread.
    ///
    /// Returns a **stream of state snapshots** in reverse chronological order
    /// (most recent first), enabling time-travel debugging, audit trails, and
    /// state evolution analysis.
    ///
    /// # Architecture
    ///
    /// ```text
    /// Thread Timeline (Reverse Chronological)
    ///
    /// Latest ‚îÄ‚îÄ‚îê
    ///          ‚îÇ
    ///          ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Checkpoint  ‚îÇ ‚îÄ‚îÄ> ‚îÇ Checkpoint  ‚îÇ ‚îÄ‚îÄ> ‚îÇ Checkpoint  ‚îÇ
    /// ‚îÇ     N       ‚îÇ     ‚îÇ    N-1      ‚îÇ     ‚îÇ    N-2      ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ                   ‚îÇ                   ‚îÇ
    ///        ‚ñº                   ‚ñº                   ‚ñº
    ///  StateSnapshot       StateSnapshot       StateSnapshot
    ///
    /// Stream yields snapshots from N ‚Üí N-1 ‚Üí N-2 ‚Üí ...
    /// ```
    ///
    /// # Arguments
    ///
    /// * `config` - Base checkpoint configuration (thread_id required)
    /// * `filter` - Optional metadata filter to select specific checkpoints
    ///   - Example: `{"source": "human"}` to find human interventions
    /// * `before` - Optional configuration to list checkpoints before this one
    /// * `limit` - Optional maximum number of snapshots to return
    ///
    /// # Returns
    ///
    /// Stream of [`StateSnapshot`] in reverse chronological order. Empty stream if
    /// no checkpointer configured or no matching checkpoints found.
    ///
    /// # Example: Complete Execution History
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, CheckpointConfig};
    /// use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// use futures::stream::StreamExt;
    /// use std::sync::Arc;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// graph.add_node("step1", |mut state| {
    ///     Box::pin(async move {
    ///         state["step"] = serde_json::json!(1);
    ///         Ok(state)
    ///     })
    /// });
    /// graph.add_node("step2", |mut state| {
    ///     Box::pin(async move {
    ///         state["step"] = serde_json::json!(2);
    ///         Ok(state)
    ///     })
    /// });
    /// graph.add_edge("__start__", "step1");
    /// graph.add_edge("step1", "step2");
    /// graph.add_edge("step2", "__end__");
    ///
    /// let saver = Arc::new(InMemoryCheckpointSaver::new());
    /// let compiled = graph.compile()?.with_checkpointer(saver);
    ///
    /// // Execute graph
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("workflow-history")
    ///     .build();
    /// compiled.invoke_with_config(
    ///     serde_json::json!({"input": "data"}),
    ///     config.clone()
    /// ).await?;
    ///
    /// // Traverse full history
    /// let mut history = compiled.get_state_history(&config, None, None, None).await?;
    ///
    /// println!("üìú Execution History:");
    /// let mut step_num = 0;
    /// while let Some(snapshot) = history.next().await {
    ///     let snapshot = snapshot?;
    ///     step_num += 1;
    ///     println!("  Step {}: {:?}", step_num, snapshot.values.get("step"));
    ///     println!("    Tasks: {:?}", snapshot.tasks);
    ///     println!("    Next: {:?}", snapshot.next);
    ///     println!("    Time: {:?}", snapshot.created_at);
    ///     println!();
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Finding Human Interventions
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use futures::stream::StreamExt;
    /// # use std::sync::Arc;
    /// # use std::collections::HashMap;
    /// # use serde_json::{json, Value};
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// // Filter checkpoints by metadata
    /// let mut filter = HashMap::new();
    /// filter.insert("source".to_string(), json!("human"));
    /// filter.insert("approved".to_string(), json!(true));
    ///
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("approval-workflow")
    ///     .build();
    ///
    /// let mut history = compiled.get_state_history(
    ///     &config,
    ///     Some(filter),  // Only human-approved checkpoints
    ///     None,
    ///     Some(5)        // Last 5 interventions
    /// ).await?;
    ///
    /// println!("üë§ Human Interventions:");
    /// while let Some(snapshot) = history.next().await {
    ///     let snapshot = snapshot?;
    ///     if let Some(reviewer) = snapshot.metadata.get("reviewer") {
    ///         println!("  Reviewer: {}", reviewer);
    ///         println!("  Time: {:?}", snapshot.created_at);
    ///         println!("  Changes: {:#?}", snapshot.values);
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Time-Travel Debugging
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use futures::stream::StreamExt;
    /// # use std::sync::Arc;
    /// # use serde_json::json;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// // Find the checkpoint just before an error occurred
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("debug-session")
    ///     .build();
    ///
    /// let mut history = compiled.get_state_history(&config, None, None, None).await?;
    ///
    /// let mut previous_good_state = None;
    /// while let Some(snapshot) = history.next().await {
    ///     let snapshot = snapshot?;
    ///
    ///     // Check if this checkpoint has an error
    ///     if snapshot.values.get("error").is_some() {
    ///         println!("‚ùå Error found at {:?}", snapshot.created_at);
    ///
    ///         // The previous snapshot is the last good state
    ///         if let Some(good_state) = previous_good_state {
    ///             println!("‚úÖ Last good state: {:#?}", good_state);
    ///
    ///             // Resume from the good state
    ///             let resume_config = CheckpointConfig::builder()
    ///                 .with_thread_id("debug-session")
    ///                 .with_checkpoint_id(good_state.config.checkpoint_id.unwrap())
    ///                 .build();
    ///
    ///             compiled.invoke_with_config(
    ///                 json!({"retry": true}),
    ///                 resume_config
    ///             ).await?;
    ///         }
    ///         break;
    ///     }
    ///
    ///     previous_good_state = Some(snapshot);
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Checkpoint Pagination
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use futures::stream::StreamExt;
    /// # use std::sync::Arc;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("paginated-workflow")
    ///     .build();
    ///
    /// // First page: Get latest 10 checkpoints
    /// let mut page1 = compiled.get_state_history(&config, None, None, Some(10)).await?;
    ///
    /// let mut last_checkpoint = None;
    /// while let Some(snapshot) = page1.next().await {
    ///     let snapshot = snapshot?;
    ///     println!("Page 1: {:?}", snapshot.created_at);
    ///     last_checkpoint = Some(snapshot.config.clone());
    /// }
    ///
    /// // Second page: Get next 10 checkpoints
    /// if let Some(last) = last_checkpoint {
    ///     let mut page2 = compiled.get_state_history(
    ///         &config,
    ///         None,
    ///         Some(&last),  // Start from last checkpoint of page 1
    ///         Some(10)
    ///     ).await?;
    ///
    ///     while let Some(snapshot) = page2.next().await {
    ///         let snapshot = snapshot?;
    ///         println!("Page 2: {:?}", snapshot.created_at);
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Use Cases
    ///
    /// 1. **Audit Trail**: Complete record of state changes
    /// 2. **Time-Travel Debugging**: Find when issues occurred
    /// 3. **Analytics**: Analyze execution patterns over time
    /// 4. **Compliance**: Track all modifications and approvals
    /// 5. **Replay**: Understand how the graph reached its current state
    ///
    /// # Performance Considerations
    ///
    /// - **Streaming**: Results are streamed (not loaded all at once)
    /// - **Lazy Evaluation**: Checkpoints loaded on-demand as you iterate
    /// - **Pagination**: Use `limit` and `before` for large histories
    /// - **Filtering**: Apply filters to reduce checkpoint backend queries
    ///
    /// # See Also
    ///
    /// - [`get_state`](Self::get_state) - Get single checkpoint
    /// - [`update_state`](Self::update_state) - Modify checkpoint state
    /// - [`StateSnapshot`] - Structure of returned state data
    /// - [`CheckpointSaver::list`] - Underlying checkpoint iteration
    pub async fn get_state_history(
        &self,
        config: &CheckpointConfig,
        filter: Option<HashMap<String, Value>>,
        before: Option<&CheckpointConfig>,
        limit: Option<usize>,
    ) -> Result<StateSnapshotStream> {
        let Some(saver) = self.checkpoint_saver.clone() else {
            // No checkpointer configured, return empty stream
            return Ok(Box::pin(futures::stream::empty()));
        };

        let checkpoint_stream = saver.list(Some(config), filter, before, limit).await
            .map_err(|e| GraphError::Checkpoint(e))?;

        // Convert CheckpointTuple stream to StateSnapshot stream
        let snapshot_stream = checkpoint_stream.map(|result| {
            result
                .map(|tuple| Self::checkpoint_tuple_to_snapshot_static(tuple))
                .map_err(|e| GraphError::Checkpoint(e))
        });

        Ok(Box::pin(snapshot_stream))
    }

    /// Helper to convert a CheckpointTuple to a StateSnapshot (instance method)
    fn checkpoint_tuple_to_snapshot(&self, tuple: CheckpointTuple) -> StateSnapshot {
        Self::checkpoint_tuple_to_snapshot_static(tuple)
    }

    /// Helper to convert a CheckpointTuple to a StateSnapshot (static method)
    pub(crate) fn checkpoint_tuple_to_snapshot_static(tuple: CheckpointTuple) -> StateSnapshot {
        // Extract state values from checkpoint channels
        let values = Self::extract_state_from_checkpoint(&tuple.checkpoint);

        // Determine next nodes from versions_seen
        // Nodes that haven't seen the latest channel versions need to execute next
        let next: Vec<String> = tuple.checkpoint.versions_seen
            .keys()
            .filter(|node_id| {
                // Check if node has seen all latest channel versions
                let node_versions = tuple.checkpoint.versions_seen.get(*node_id);
                if let Some(nv) = node_versions {
                    // If any channel version differs, this node needs to execute
                    tuple.checkpoint.channel_versions.iter().any(|(ch, ver)| {
                        nv.get(ch).map(|v| v != ver).unwrap_or(true)
                    })
                } else {
                    true
                }
            })
            .map(|s| s.to_string())
            .collect();

        StateSnapshot {
            values,
            next,
            config: tuple.config,
            metadata: Some(tuple.metadata),
            created_at: Some(tuple.checkpoint.ts.to_rfc3339()),
            parent_config: tuple.parent_config,
        }
    }

    /// Helper to extract state values from a checkpoint
    fn extract_state_from_checkpoint(checkpoint: &langgraph_checkpoint::Checkpoint) -> Value {
        // Extract values from checkpoint channels
        let mut state = serde_json::Map::new();

        for (channel_name, channel_value) in &checkpoint.channel_values {
            // Channel values are already JSON Values, so just clone them
            state.insert(channel_name.clone(), channel_value.clone());
        }

        Value::Object(state)
    }

    /// Modify graph state between executions.
    ///
    /// This method allows **manual state modification** outside the normal graph
    /// execution flow. It's essential for:
    /// - Correcting errors in state
    /// - Injecting external data
    /// - Implementing human-in-the-loop patterns
    /// - Testing specific state scenarios
    ///
    /// # Architecture
    ///
    /// ```text
    /// Current Checkpoint
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Load State   ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Merge Values ‚îÇ ‚óÑ‚îÄ‚îÄ New values
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Apply Reducer‚îÇ ‚óÑ‚îÄ‚îÄ If as_node specified
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///        ‚îÇ
    ///        ‚ñº
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Save New     ‚îÇ
    /// ‚îÇ Checkpoint   ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    /// ```
    ///
    /// # Arguments
    ///
    /// * `config` - Checkpoint configuration identifying which thread/checkpoint to update
    /// * `values` - State values to merge with existing state (object will be merged, primitives replaced)
    /// * `as_node` - Optional node name to update as (affects reducer behavior and permissions)
    ///
    /// # Returns
    ///
    /// New [`CheckpointConfig`] pointing to the updated checkpoint. Use this config
    /// for subsequent operations to continue from the updated state.
    ///
    /// # Example: Correcting State Errors
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, CheckpointConfig};
    /// use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// use serde_json::json;
    /// use std::sync::Arc;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// graph.add_node("process", |state| {
    ///     Box::pin(async move {
    ///         // Node that might produce incorrect state
    ///         Ok(state)
    ///     })
    /// });
    /// graph.add_edge("__start__", "process");
    /// graph.add_edge("process", "__end__");
    ///
    /// let saver = Arc::new(InMemoryCheckpointSaver::new());
    /// let compiled = graph.compile()?.with_checkpointer(saver);
    ///
    /// // Initial execution
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("conversation-123")
    ///     .build();
    /// let result = compiled.invoke_with_config(
    ///     json!({"data": "initial"}),
    ///     config.clone()
    /// ).await?;
    ///
    /// // Manually correct an error in the state
    /// let updated_config = compiled.update_state(
    ///     &config,
    ///     json!({
    ///         "error": null,
    ///         "status": "corrected",
    ///         "data": "fixed_value"
    ///     }),
    ///     None  // Update as the system, not as any specific node
    /// ).await?;
    ///
    /// // Continue execution with corrected state
    /// let result = compiled.invoke_with_config(
    ///     json!({"next_input": "continue"}),
    ///     updated_config
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Human-in-the-Loop Pattern
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use serde_json::json;
    /// # use std::sync::Arc;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let mut graph = StateGraph::new();
    /// # graph.add_node("ai", |s| Box::pin(async move { Ok(s) }));
    /// # graph.add_edge("__start__", "ai");
    /// # graph.add_edge("ai", "__end__");
    /// # let compiled = graph.compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// // Graph execution paused at interrupt point
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("approval-workflow")
    ///     .build();
    ///
    /// // Human reviews and approves with modifications
    /// let human_feedback = json!({
    ///     "approved": true,
    ///     "modifications": ["change A", "change B"],
    ///     "reviewer": "alice@example.com",
    ///     "reviewed_at": "2024-01-15T10:00:00Z"
    /// });
    ///
    /// // Update state with human feedback
    /// let updated_config = compiled.update_state(
    ///     &config,
    ///     human_feedback,
    ///     Some("human_review".to_string())  // Update as specific node
    /// ).await?;
    ///
    /// // Resume execution with human input
    /// let result = compiled.invoke_with_config(
    ///     json!({}),  // Empty input, just resume
    ///     updated_config
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Testing with Specific States
    ///
    /// ```rust,no_run
    /// # use langgraph_core::{StateGraph, CheckpointConfig};
    /// # use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// # use serde_json::json;
    /// # use std::sync::Arc;
    /// #
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?.with_checkpointer(Arc::new(InMemoryCheckpointSaver::new()));
    /// // Set up specific test scenario
    /// let test_config = CheckpointConfig::builder()
    ///     .with_thread_id("test-edge-case")
    ///     .build();
    ///
    /// // Initialize checkpoint first
    /// let test_config = compiled.invoke_with_config(
    ///     json!({"init": true}),
    ///     test_config.clone()
    /// ).await.map(|_| test_config)?;
    ///
    /// // Inject edge case state
    /// let edge_case_state = json!({
    ///     "counter": i32::MAX - 1,
    ///     "buffer": vec![0u8; 1024],
    ///     "flags": {
    ///         "overflow_protection": true,
    ///         "strict_mode": true
    ///     }
    /// });
    ///
    /// let test_config = compiled.update_state(
    ///     &test_config,
    ///     edge_case_state,
    ///     None
    /// ).await?;
    ///
    /// // Run graph with edge case state
    /// let result = compiled.invoke_with_config(
    ///     json!({"test": "overflow"}),
    ///     test_config
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Reducer Behavior with `as_node`
    ///
    /// When `as_node` is specified, the update behaves as if that node produced
    /// the values. This affects how reducers are applied:
    ///
    /// - **Without `as_node`**: Values are directly merged/replaced
    /// - **With `as_node`**: Node's configured reducers are applied
    ///
    /// ```rust,ignore
    /// // Direct replacement (no reducer)
    /// update_state(&config, json!({"messages": ["new"]}), None).await?;
    /// // State: {"messages": ["new"]}
    ///
    /// // With reducer (e.g., append for messages)
    /// update_state(&config, json!({"messages": ["new"]}), Some("agent")).await?;
    /// // State: {"messages": ["old1", "old2", "new"]}  // Appended
    /// ```
    ///
    /// # Errors
    ///
    /// Returns error if:
    /// - No checkpoint saver is configured
    /// - Checkpoint doesn't exist for given config
    /// - Checkpoint save operation fails
    ///
    /// # Performance Notes
    ///
    /// - Loads entire checkpoint into memory
    /// - Creates new checkpoint version (doesn't modify in-place)
    /// - Thread-safe when using concurrent-safe checkpoint backend
    ///
    /// # See Also
    ///
    /// - [`get_state`](Self::get_state) - Read current state
    /// - [`get_state_history`](Self::get_state_history) - View state evolution
    /// - [`invoke_with_config`](Self::invoke_with_config) - Resume from checkpoint
    /// - [`CheckpointSaver`] - Checkpoint persistence interface
    pub async fn update_state(
        &self,
        config: &CheckpointConfig,
        values: Value,
        as_node: Option<String>,
    ) -> Result<CheckpointConfig> {
        let Some(saver) = &self.checkpoint_saver else {
            return Err(GraphError::Configuration(
                "No checkpoint saver configured".to_string()
            ));
        };

        // Get current checkpoint
        let checkpoint_tuple = saver.get_tuple(config).await
            .map_err(|e| GraphError::Checkpoint(e))?
            .ok_or_else(|| GraphError::Configuration(
                format!("No checkpoint found for config: {:?}", config)
            ))?;

        // Merge values into current state
        let mut updated_state = checkpoint_tuple.checkpoint.channel_values.clone();
        if let Value::Object(new_values) = values {
            for (key, value) in new_values {
                updated_state.insert(key, value);
            }
        }

        // Create new checkpoint with updated state
        let mut new_checkpoint = checkpoint_tuple.checkpoint.clone();
        new_checkpoint.channel_values = updated_state;
        new_checkpoint.ts = chrono::Utc::now();

        // Update metadata to indicate manual update
        let mut metadata = checkpoint_tuple.metadata.clone();
        if let Some(node) = as_node {
            metadata.extra.insert("updated_by".to_string(), serde_json::json!(node));
        }
        metadata.extra.insert("manual_update".to_string(), serde_json::json!(true));

        // Save updated checkpoint
        let new_config = saver.put(
            config,
            new_checkpoint,
            metadata,
            HashMap::new(), // No new channel versions for manual update
        ).await.map_err(|e| GraphError::Checkpoint(e))?;

        Ok(new_config)
    }

    /// Update state for multiple checkpoints in a single operation
    ///
    /// This is useful for batch operations when you need to update multiple
    /// threads or checkpoints simultaneously.
    ///
    /// # Arguments
    ///
    /// * `updates` - List of (config, values, as_node) tuples to update
    ///
    /// # Returns
    ///
    /// Vector of updated checkpoint configurations in the same order
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, CheckpointConfig};
    /// use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// use serde_json::json;
    /// use std::sync::Arc;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// # graph.add_node("process", |state| Box::pin(async move { Ok(state) }));
    /// # graph.add_edge("__start__", "process");
    /// # graph.add_edge("process", "__end__");
    ///
    /// let saver = Arc::new(InMemoryCheckpointSaver::new());
    /// let compiled = graph.compile()?.with_checkpointer(saver);
    ///
    /// let updates = vec![
    ///     (
    ///         CheckpointConfig::new().with_thread_id("thread_1".to_string()),
    ///         json!({"status": "updated"}),
    ///         None
    ///     ),
    ///     (
    ///         CheckpointConfig::new().with_thread_id("thread_2".to_string()),
    ///         json!({"status": "updated"}),
    ///         None
    ///     ),
    /// ];
    ///
    /// let new_configs = compiled.bulk_update_state(updates).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn bulk_update_state(
        &self,
        updates: Vec<(CheckpointConfig, Value, Option<String>)>,
    ) -> Result<Vec<CheckpointConfig>> {
        let mut results = Vec::new();

        for (config, values, as_node) in updates {
            let new_config = self.update_state(&config, values, as_node).await?;
            results.push(new_config);
        }

        Ok(results)
    }

    /// Execute the graph with the given input using the Pregel execution engine
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state
    ///
    /// # Returns
    ///
    /// Execute the graph with the given input state.
    ///
    /// This is the primary method for running a compiled graph. It executes
    /// the graph to completion (or interruption) and returns the final state.
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state as JSON value. Structure depends on your graph's state schema.
    ///
    /// # Returns
    ///
    /// Returns the final state after all nodes have executed, or an error if:
    /// - Execution fails
    /// - Maximum steps exceeded
    /// - Graph is interrupted (returns `GraphError::Interrupt`)
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    /// use serde_json::json;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// graph.add_node("process", |state| {
    ///     Box::pin(async move {
    ///         // Process logic
    ///         Ok(state)
    ///     })
    /// });
    /// graph.add_edge("__start__", "process");
    /// graph.add_edge("process", "__end__");
    ///
    /// let compiled = graph.compile()?;
    ///
    /// // Execute with initial state
    /// let result = compiled.invoke(json!({
    ///     "messages": ["Hello"],
    ///     "count": 0
    /// })).await?;
    ///
    /// println!("Final state: {:?}", result);
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # See Also
    ///
    /// - [`invoke_with_config`](Self::invoke_with_config) - Execute with checkpoint configuration
    /// - [`stream_chunks_with_modes`](Self::stream_chunks_with_modes) - Stream execution events
    /// - [`batch`](Self::batch) - Process multiple inputs
    pub async fn invoke(&self, input: Value) -> Result<Value> {
        self.invoke_with_config(input, None).await
    }

    /// Execute the graph with checkpoint configuration for resumption and persistence.
    ///
    /// This method enables advanced execution scenarios including:
    /// - **Resumption**: Continue from a previous checkpoint
    /// - **Persistence**: Save checkpoints for recovery
    /// - **Threading**: Maintain separate execution threads
    /// - **Time-travel**: Jump to any checkpoint in history
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state (or state to merge when resuming)
    /// * `config` - Checkpoint configuration with thread_id and optional checkpoint_id
    ///
    /// # Returns
    ///
    /// Final state after execution completes or is interrupted.
    ///
    /// # Execution Modes
    ///
    /// ## Fresh Start (New Thread)
    ///
    /// ```rust,ignore
    /// let config = Some(CheckpointConfig::new("thread-1"));
    /// let result = compiled.invoke_with_config(initial_state, config).await?;
    /// ```
    ///
    /// ## Resume from Latest Checkpoint
    ///
    /// ```rust,ignore
    /// let config = Some(CheckpointConfig::new("thread-1"));
    /// // Automatically resumes from the latest checkpoint for this thread
    /// let result = compiled.invoke_with_config(new_input, config).await?;
    /// ```
    ///
    /// ## Resume from Specific Checkpoint
    ///
    /// ```rust,ignore
    /// let config = Some(CheckpointConfig::new("thread-1")
    ///     .with_checkpoint_id("checkpoint-123"));
    /// let result = compiled.invoke_with_config(Value::Null, config).await?;
    /// ```
    ///
    /// # Example: Multi-Turn Conversation
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, CheckpointConfig};
    /// use langgraph_checkpoint::InMemoryCheckpointSaver;
    /// use serde_json::json;
    /// use std::sync::Arc;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// // Create graph with checkpointer
    /// let mut graph = StateGraph::new();
    /// // ... add nodes and edges ...
    ///
    /// let checkpointer = Arc::new(InMemoryCheckpointSaver::new());
    /// let compiled = graph.compile()?
    ///     .with_checkpointer(checkpointer);
    ///
    /// let config = Some(CheckpointConfig::new("conversation-1"));
    ///
    /// // Turn 1: Initial message
    /// let result1 = compiled.invoke_with_config(
    ///     json!({"messages": ["Hello"]}),
    ///     config.clone()
    /// ).await?;
    ///
    /// // Turn 2: Continue conversation (auto-resumes from checkpoint)
    /// let result2 = compiled.invoke_with_config(
    ///     json!({"messages": ["Tell me more"]}),
    ///     config.clone()
    /// ).await?;
    ///
    /// // State accumulates across turns
    /// println!("Conversation history: {:?}", result2);
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Interrupt Handling
    ///
    /// If the graph has interrupt points configured, execution may pause:
    ///
    /// ```rust,ignore
    /// match compiled.invoke_with_config(input, config).await {
    ///     Ok(final_state) => println!("Complete: {:?}", final_state),
    ///     Err(GraphError::Interrupt(state)) => {
    ///         println!("Interrupted, waiting for input");
    ///         // Get user input, then resume with updated state
    ///         let resume_state = get_user_input(state);
    ///         compiled.invoke_with_config(resume_state, config).await?;
    ///     }
    ///     Err(e) => return Err(e),
    /// }
    /// ```
    ///
    /// # Performance
    ///
    /// - **Checkpointing**: Adds ~10-20ms per superstep for serialization
    /// - **Thread Lookup**: O(1) for in-memory, varies for persistent backends
    /// - **State Size**: Checkpoint size proportional to state complexity
    ///
    /// # See Also
    ///
    /// - [`CheckpointConfig`] - Configuration options
    /// - [`update_state`](Self::update_state) - Modify state between executions
    /// - [`get_state`](Self::get_state) - Inspect current state
    #[tracing::instrument(skip(self, input), fields(node_count = self.graph.nodes.len()))]
    pub async fn invoke_with_config(
        &self,
        input: Value,
        config: Option<CheckpointConfig>,
    ) -> Result<Value> {
        tracing::info!("Starting graph execution");

        // Build the Pregel execution context
        let mut pregel_loop = self.build_pregel_loop(input)
            .map_err(|e| {
                tracing::error!(error = %e, "Failed to build Pregel loop");
                e
            })?;

        // Set checkpointer if both saver and config are available
        if let (Some(saver), Some(cfg)) = (&self.checkpoint_saver, config) {
            tracing::debug!("Configuring checkpointer");
            pregel_loop = pregel_loop.with_checkpointer(saver.clone(), cfg);
        }

        // Set interrupt configuration
        if !self.interrupt_config.interrupt_before.is_empty() {
            tracing::debug!(
                interrupt_before = ?self.interrupt_config.interrupt_before,
                "Configuring interrupt points (before)"
            );
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_before.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_before(nodes);
        }
        if !self.interrupt_config.interrupt_after.is_empty() {
            tracing::debug!(
                interrupt_after = ?self.interrupt_config.interrupt_after,
                "Configuring interrupt points (after)"
            );
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_after.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_after(nodes);
        }

        // Run the Pregel loop
        tracing::debug!("Running Pregel execution");
        let result = pregel_loop.run().await
            .map_err(|e| {
                tracing::error!(error = %e, "Graph execution failed");
                e
            })?;

        tracing::info!("Graph execution completed successfully");
        Ok(result)
    }

    /// Stream execution events with default mode (Values)
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state
    ///
    /// # Returns
    ///
    /// Stream of execution events
    pub async fn stream(&self, input: Value) -> Result<EventStream> {
        use crate::stream::StreamMode;
        self.stream_with_modes(input, vec![StreamMode::Values], None).await
    }

    /// Stream execution events with specified modes
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state
    /// * `modes` - Stream modes to enable (Values, Updates, Tasks, etc.)
    /// * `config` - Optional checkpoint configuration
    ///
    /// # Returns
    ///
    /// Stream of execution events
    pub async fn stream_with_modes(
        &self,
        input: Value,
        modes: Vec<crate::stream::StreamMode>,
        config: Option<CheckpointConfig>,
    ) -> Result<EventStream> {
        use tokio::sync::mpsc;

        // Create channel for streaming events
        let (tx, mut rx) = mpsc::unbounded_channel();

        // Build Pregel loop with streaming enabled
        let mut pregel_loop = self.build_pregel_loop(input)?;

        // Configure streaming
        pregel_loop = pregel_loop.with_streaming(modes, tx);

        // Set checkpointer if both saver and config are available
        if let (Some(saver), Some(cfg)) = (&self.checkpoint_saver, config) {
            pregel_loop = pregel_loop.with_checkpointer(saver.clone(), cfg);
        }

        // Set interrupt configuration
        if !self.interrupt_config.interrupt_before.is_empty() {
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_before.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_before(nodes);
        }
        if !self.interrupt_config.interrupt_after.is_empty() {
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_after.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_after(nodes);
        }

        // Spawn the execution in a background task
        tokio::spawn(async move {
            let _ = pregel_loop.run().await;
        });

        // Convert StreamEvent to ExecutionEvent
        let event_stream = async_stream::stream! {
            while let Some(event) = rx.recv().await {
                yield convert_stream_event(event);
            }
        };

        Ok(Box::pin(event_stream))
    }

    /// Stream graph execution with fine-grained control over event types.
    ///
    /// This is the **recommended streaming API** for production use. It provides
    /// bounded channels for backpressure control and returns structured `StreamChunk`
    /// events with mode and namespace metadata.
    ///
    /// # Architecture
    ///
    /// ```text
    /// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    Bounded Channel (100)    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    /// ‚îÇ Pregel Loop  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îÇ   Client    ‚îÇ
    /// ‚îÇ   Executor   ‚îÇ        StreamChunk           ‚îÇ   Consumer  ‚îÇ
    /// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ///       ‚Üì
    ///   Backpressure: Channel blocks when full
    /// ```
    ///
    /// # Stream Modes
    ///
    /// Control what events you receive:
    /// - `Values` - Complete state after each node execution
    /// - `Updates` - State changes/patches from each node
    /// - `Tasks` - Task execution details (node start/end)
    /// - `Messages` - Message-specific events (for MessageGraph)
    /// - `Debug` - Internal debugging information
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state to start execution with
    /// * `modes` - Stream modes to enable (combine multiple for comprehensive monitoring)
    /// * `config` - Optional checkpoint configuration for resumption
    ///
    /// # Returns
    ///
    /// A stream of [`StreamChunk`] containing events with:
    /// - `mode` - The [`StreamMode`] that generated this event
    /// - `event` - The actual event data (state, update, or task info)
    /// - `namespace` - Hierarchical path for subgraph events
    ///
    /// # Example: Real-time Execution Monitoring
    ///
    /// ```rust,no_run
    /// use langgraph_core::{StateGraph, StreamMode};
    /// use serde_json::json;
    /// use futures::StreamExt;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// let mut graph = StateGraph::new();
    /// graph.add_node("process", |state| {
    ///     Box::pin(async move {
    ///         // Simulate work
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///         Ok(json!({"processed": true}))
    ///     })
    /// });
    /// graph.add_edge("__start__", "process");
    /// graph.add_edge("process", "__end__");
    /// let compiled = graph.compile()?;
    ///
    /// // Stream with multiple modes for comprehensive monitoring
    /// let mut stream = compiled.stream_chunks_with_modes(
    ///     json!({"input": "data"}),
    ///     vec![
    ///         StreamMode::Values,   // Get full state
    ///         StreamMode::Updates,  // Get incremental changes
    ///         StreamMode::Tasks,    // Get execution progress
    ///     ],
    ///     None
    /// ).await?;
    ///
    /// // Process events as they arrive
    /// while let Some(chunk) = stream.next().await {
    ///     match chunk.mode {
    ///         StreamMode::Tasks => {
    ///             println!("‚ö° Task event: {:?}", chunk.event);
    ///         }
    ///         StreamMode::Updates => {
    ///             println!("üìù State update: {:?}", chunk.event);
    ///         }
    ///         StreamMode::Values => {
    ///             println!("üìä Full state: {:?}", chunk.event);
    ///         }
    ///         _ => {}
    ///     }
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Example: Resumable Streaming with Checkpoints
    ///
    /// ```rust,no_run
    /// use langgraph_core::{CheckpointConfig, StreamMode};
    /// # use langgraph_core::StateGraph;
    /// # use serde_json::json;
    /// # use futures::StreamExt;
    ///
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let compiled = StateGraph::new().compile()?;
    /// // Configure checkpoint for resumption
    /// let config = CheckpointConfig::builder()
    ///     .with_thread_id("conversation-123")
    ///     .with_checkpoint_ns("user-456")
    ///     .build();
    ///
    /// // Stream from last checkpoint (if exists)
    /// let mut stream = compiled.stream_chunks_with_modes(
    ///     json!({"message": "Continue our discussion"}),
    ///     vec![StreamMode::Values],
    ///     Some(config)
    /// ).await?;
    ///
    /// // Process resumable stream
    /// while let Some(chunk) = stream.next().await {
    ///     // Each chunk is automatically checkpointed
    ///     println!("Resumable state: {:?}", chunk.event);
    /// }
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Performance Considerations
    ///
    /// - **Bounded Channel**: Uses a 100-item buffer to prevent memory exhaustion
    /// - **Backpressure**: Automatically slows execution if consumer can't keep up
    /// - **Selective Modes**: Only enable modes you need to reduce overhead
    /// - **Async Execution**: Runs in separate Tokio task for non-blocking operation
    ///
    /// # Migration from Legacy API
    ///
    /// ```rust,ignore
    /// // Old API (deprecated)
    /// let stream = compiled.stream_with_modes(
    ///     input,
    ///     vec!["values"],
    ///     None
    /// ).await?;
    ///
    /// // New API (recommended)
    /// let stream = compiled.stream_chunks_with_modes(
    ///     input,
    ///     vec![StreamMode::Values],
    ///     None
    /// ).await?;
    /// ```
    ///
    /// # See Also
    ///
    /// - [`StreamMode`] - Available streaming modes
    /// - [`StreamChunk`] - Structure of streamed events
    /// - [`stream_with_modes`](Self::stream_with_modes) - Legacy streaming API
    /// - [`invoke_with_config`](Self::invoke_with_config) - Non-streaming execution
    pub async fn stream_chunks_with_modes(
        &self,
        input: Value,
        modes: Vec<StreamMode>,
        config: Option<CheckpointConfig>,
    ) -> Result<StreamChunkStream> {
        use tokio::sync::mpsc;
        use tokio_stream::wrappers::ReceiverStream;

        // Create BOUNDED channel for backpressure (100 item buffer)
        let (tx, rx) = mpsc::channel::<StreamChunk>(100);

        // Build Pregel loop with streaming enabled
        let mut pregel_loop = self.build_pregel_loop(input)?;

        // Configure streaming with new API
        pregel_loop = pregel_loop.with_streaming_mux(modes, tx);

        // Set checkpointer if both saver and config are available
        if let (Some(saver), Some(cfg)) = (&self.checkpoint_saver, config) {
            pregel_loop = pregel_loop.with_checkpointer(saver.clone(), cfg);
        }

        // Set interrupt configuration
        if !self.interrupt_config.interrupt_before.is_empty() {
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_before.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_before(nodes);
        }
        if !self.interrupt_config.interrupt_after.is_empty() {
            let nodes: std::collections::HashSet<String> =
                self.interrupt_config.interrupt_after.iter().cloned().collect();
            pregel_loop = pregel_loop.with_interrupt_after(nodes);
        }

        // Spawn the execution in a background task
        tokio::spawn(async move {
            if let Err(e) = pregel_loop.run().await {
                tracing::error!(error = %e, "Streaming execution failed");
            }
        });

        // Return stream of chunks directly
        Ok(Box::pin(ReceiverStream::new(rx)))
    }

    /// Get the underlying graph
    pub fn graph(&self) -> &Graph {
        &self.graph
    }

    /// Get the interrupt configuration
    pub fn interrupt_config(&self) -> &InterruptConfig {
        &self.interrupt_config
    }

    /// Set the interrupt configuration
    pub fn with_interrupt_config(mut self, config: InterruptConfig) -> Self {
        self.interrupt_config = config;
        self
    }

    /// Get the checkpoint saver (internal use)
    pub(crate) fn get_checkpoint_saver(&self) -> Option<Arc<dyn CheckpointSaver>> {
        self.checkpoint_saver.clone()
    }

    // ===== FUNCTIONAL COMPOSITION METHODS =====

    /// Chain this graph with another graph sequentially
    ///
    /// Creates a new graph that executes this graph, then passes the output
    /// to the next graph. This is sequential composition (pipe operator).
    ///
    /// # Arguments
    ///
    /// * `next` - The graph to execute after this one
    ///
    /// # Returns
    ///
    /// A new `CompiledGraph` that sequences both graphs
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut first = StateGraph::new();
    /// first.add_node("process1", |state| {
    ///     Box::pin(async move { Ok(state) })
    /// });
    /// first.add_edge("__start__", "process1");
    /// first.add_edge("process1", "__end__");
    ///
    /// let mut second = StateGraph::new();
    /// second.add_node("process2", |state| {
    ///     Box::pin(async move { Ok(state) })
    /// });
    /// second.add_edge("__start__", "process2");
    /// second.add_edge("process2", "__end__");
    ///
    /// // Chain them: first -> second
    /// let chained = first.compile()?.then(second.compile()?);
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn then(self, next: CompiledGraph) -> CompiledGraph {
        use crate::builder::StateGraph;

        let mut combined = StateGraph::new();

        // Add first graph as a subgraph
        combined.add_subgraph("first", self);

        // Add second graph as a subgraph
        combined.add_subgraph("second", next);

        // Chain them sequentially
        combined.add_edge("__start__", "first");
        combined.add_edge("first", "second");
        combined.add_edge("second", "__end__");

        // Compile should not fail since we control the structure
        combined.compile().expect("Sequential composition should always succeed")
    }

    /// Transform the output of this graph
    ///
    /// Creates a new graph that executes this graph, then applies a transformation
    /// function to the output.
    ///
    /// # Arguments
    ///
    /// * `f` - Transformation function
    ///
    /// # Returns
    ///
    /// A new `CompiledGraph` with the transformation applied
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    /// use serde_json::json;
    ///
    /// let mut graph = StateGraph::new();
    /// graph.add_node("process", |state| {
    ///     Box::pin(async move { Ok(state) })
    /// });
    /// graph.add_edge("__start__", "process");
    /// graph.add_edge("process", "__end__");
    ///
    /// let compiled = graph.compile()?.map(|mut output| {
    ///     Box::pin(async move {
    ///         if let Some(obj) = output.as_object_mut() {
    ///             obj.insert("transformed".to_string(), json!(true));
    ///         }
    ///         Ok(output)
    ///     })
    /// });
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn map<F>(self, f: F) -> CompiledGraph
    where
        F: Fn(Value) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<Value>> + Send>>
            + Send
            + Sync
            + 'static,
    {
        use crate::builder::StateGraph;

        let mut combined = StateGraph::new();

        // Add original graph as subgraph
        combined.add_subgraph("graph", self);

        // Add transformation node
        combined.add_node("transform", f);

        // Chain them
        combined.add_edge("__start__", "graph");
        combined.add_edge("graph", "transform");
        combined.add_edge("transform", "__end__");

        combined.compile().expect("Map composition should always succeed")
    }

    /// Chain multiple graphs sequentially
    ///
    /// This is a convenience method for chaining more than two graphs.
    ///
    /// # Arguments
    ///
    /// * `graphs` - Vector of graphs to chain
    ///
    /// # Returns
    ///
    /// A new `CompiledGraph` that sequences all graphs
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let graph1 = StateGraph::new().compile()?;
    /// let graph2 = StateGraph::new().compile()?;
    /// let graph3 = StateGraph::new().compile()?;
    ///
    /// // Chain all three: graph1 -> graph2 -> graph3
    /// let chained = CompiledGraph::chain(vec![graph1, graph2, graph3]);
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn chain(graphs: Vec<CompiledGraph>) -> Result<CompiledGraph> {
        use crate::builder::StateGraph;

        if graphs.is_empty() {
            return Err(GraphError::Validation("Cannot chain empty graph list".to_string()));
        }

        if graphs.len() == 1 {
            return Ok(graphs.into_iter().next().unwrap());
        }

        let mut combined = StateGraph::new();
        let mut prev_node = "__start__".to_string();

        // Add each graph as a subgraph and chain them
        for (i, graph) in graphs.into_iter().enumerate() {
            let node_name = format!("step_{}", i);
            combined.add_subgraph(&node_name, graph);
            combined.add_edge(&prev_node, &node_name);
            prev_node = node_name;
        }

        // Connect last node to end
        combined.add_edge(&prev_node, "__end__");

        combined.compile()
    }

    /// Execute this graph conditionally based on a predicate
    ///
    /// Creates a new graph that only executes this graph if the predicate returns true.
    /// If false, the input state passes through unchanged.
    ///
    /// # Arguments
    ///
    /// * `predicate` - Function that determines whether to execute the graph
    ///
    /// # Returns
    ///
    /// A new `CompiledGraph` with conditional execution
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// graph.add_node("expensive_process", |state| {
    ///     Box::pin(async move { Ok(state) })
    /// });
    /// graph.add_edge("__start__", "expensive_process");
    /// graph.add_edge("expensive_process", "__end__");
    ///
    /// // Only execute if "enabled" flag is true
    /// let conditional = graph.compile()?.when(|state| {
    ///     state.get("enabled")
    ///         .and_then(|v| v.as_bool())
    ///         .unwrap_or(false)
    /// });
    /// # Ok::<(), Box<dyn std::error::Error>>(())
    /// ```
    pub fn when<F>(self, predicate: F) -> CompiledGraph
    where
        F: Fn(&Value) -> bool + Send + Sync + 'static,
    {
        use crate::builder::StateGraph;
        use std::collections::HashMap;

        let mut combined = StateGraph::new();

        // Add router node that checks predicate
        let predicate = Arc::new(predicate);
        combined.add_node("router", |state| {
            Box::pin(async move {
                // Just pass state through - routing is done via conditional edge
                Ok(state)
            })
        });

        // Add the conditional graph as a subgraph
        combined.add_subgraph("conditional_graph", self);

        // Add passthrough node (does nothing)
        combined.add_node("passthrough", |state| {
            Box::pin(async move { Ok(state) })
        });

        // Set up conditional routing
        let mut branches = HashMap::new();
        branches.insert("execute".to_string(), "conditional_graph".to_string());
        branches.insert("skip".to_string(), "passthrough".to_string());

        combined.add_edge("__start__", "router");
        let predicate_clone = predicate.clone();
        combined.add_conditional_edge(
            "router",
            move |state| {
                use crate::send::ConditionalEdgeResult;
                if predicate_clone(state) {
                    ConditionalEdgeResult::Node("execute".to_string())
                } else {
                    ConditionalEdgeResult::Node("skip".to_string())
                }
            },
            branches,
        );
        combined.add_finish("conditional_graph");
        combined.add_finish("passthrough");

        combined.compile().expect("Conditional composition should always succeed")
    }

    /// Get JSON Schema for the graph's input
    ///
    /// Returns a JSON Schema object describing the expected input structure.
    /// This is useful for validation, documentation, and client code generation.
    ///
    /// # Returns
    ///
    /// JSON Schema object with properties for each input channel
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// let compiled = graph.compile().unwrap();
    ///
    /// let input_schema = compiled.get_input_schema();
    /// println!("Input schema: {}", serde_json::to_string_pretty(&input_schema).unwrap());
    /// ```
    pub fn get_input_schema(&self) -> serde_json::Value {
        use serde_json::json;

        let mut properties = serde_json::Map::new();

        // Analyze channels to build schema
        for (name, _) in &self.graph.channels {
            // Skip internal channels
            if name.starts_with("__") {
                continue;
            }

            // Skip node output channels (they're for internal routing)
            if self.graph.nodes.contains_key(name) {
                continue;
            }

            // Add channel as a property with flexible schema
            properties.insert(
                name.clone(),
                json!({
                    "description": format!("Input value for channel '{}'", name)
                }),
            );
        }

        // If no explicit channels, allow any object
        if properties.is_empty() {
            return json!({
                "type": "object",
                "description": "Graph input state",
                "additionalProperties": true
            });
        }

        json!({
            "type": "object",
            "properties": properties,
            "additionalProperties": false,
            "description": "Input schema for graph"
        })
    }

    /// Get JSON Schema for the graph's output
    ///
    /// Returns a JSON Schema object describing the output structure.
    /// This is useful for validation, documentation, and client code generation.
    ///
    /// # Returns
    ///
    /// JSON Schema object with properties for each output channel
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// let compiled = graph.compile().unwrap();
    ///
    /// let output_schema = compiled.get_output_schema();
    /// println!("Output schema: {}", serde_json::to_string_pretty(&output_schema).unwrap());
    /// ```
    pub fn get_output_schema(&self) -> serde_json::Value {
        use serde_json::json;

        let mut properties = serde_json::Map::new();

        // Analyze channels to build schema
        for (name, _) in &self.graph.channels {
            // Skip internal channels
            if name.starts_with("__") {
                continue;
            }

            // Skip node output channels (they're aggregated into state)
            if self.graph.nodes.contains_key(name) {
                continue;
            }

            // Add channel as a property with flexible schema
            properties.insert(
                name.clone(),
                json!({
                    "description": format!("Output value for channel '{}'", name)
                }),
            );
        }

        // If no explicit channels, return object schema
        if properties.is_empty() {
            return json!({
                "type": "object",
                "description": "Graph output state",
                "additionalProperties": true
            });
        }

        json!({
            "type": "object",
            "properties": properties,
            "additionalProperties": false,
            "description": "Output schema for graph"
        })
    }

    /// Get a list of all channel names in the graph
    ///
    /// Returns channel names excluding internal channels (those starting with `__`).
    /// Useful for introspection and debugging.
    ///
    /// # Returns
    ///
    /// Vector of channel names
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// let compiled = graph.compile().unwrap();
    ///
    /// let channels = compiled.get_channels();
    /// println!("Channels: {:?}", channels);
    /// ```
    pub fn get_channels(&self) -> Vec<String> {
        self.graph
            .channels
            .keys()
            .filter(|name| !name.starts_with("__"))
            .cloned()
            .collect()
    }

    /// Get the list of channels available for streaming at runtime
    ///
    /// Returns a list of channel names that can be streamed during graph execution.
    /// This excludes internal channels (prefixed with `__`) and node output channels.
    ///
    /// This method is useful for:
    /// - Determining which channels to subscribe to when streaming
    /// - Validating streaming configurations
    /// - Runtime introspection of available data streams
    ///
    /// # Returns
    ///
    /// A vector of channel names available for streaming
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// let compiled = graph.compile().unwrap();
    ///
    /// let streamable_channels = compiled.stream_channels_list();
    /// println!("Channels available for streaming: {:?}", streamable_channels);
    /// ```
    ///
    /// # Notes
    ///
    /// Currently returns all non-internal channels. In the future, this may
    /// respect a `stream_channels` configuration if one is added to the graph builder.
    pub fn stream_channels_list(&self) -> Vec<String> {
        // For now, return all non-internal, non-node-output channels
        // This matches the Python behavior when stream_channels is not explicitly set
        self.graph
            .channels
            .keys()
            .filter(|name| {
                // Exclude internal channels
                if name.starts_with("__") {
                    return false;
                }
                // Exclude node output channels (used for internal routing)
                if self.graph.nodes.contains_key(*name) {
                    return false;
                }
                true
            })
            .cloned()
            .collect()
    }

    /// Get metadata about the graph structure
    ///
    /// Returns a JSON object with information about nodes, edges, and channels.
    /// Useful for debugging and documentation.
    ///
    /// # Returns
    ///
    /// JSON object with graph metadata
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use langgraph_core::StateGraph;
    ///
    /// let mut graph = StateGraph::new();
    /// // ... build graph ...
    /// let compiled = graph.compile().unwrap();
    ///
    /// let metadata = compiled.get_metadata();
    /// println!("Graph metadata: {}", serde_json::to_string_pretty(&metadata).unwrap());
    /// ```
    pub fn get_metadata(&self) -> serde_json::Value {
        use serde_json::json;

        let node_names: Vec<&String> = self.graph.nodes.keys().collect();
        let channel_names = self.get_channels();

        let mut edges_info = Vec::new();
        for (from_node, edges) in &self.graph.edges {
            for edge in edges {
                match edge {
                    crate::graph::Edge::Direct(to_node) => {
                        edges_info.push(json!({
                            "type": "direct",
                            "from": from_node,
                            "to": to_node
                        }));
                    }
                    crate::graph::Edge::Conditional { branches, .. } => {
                        for (path_name, target) in branches {
                            edges_info.push(json!({
                                "type": "conditional",
                                "from": from_node,
                                "to": target,
                                "path": path_name
                            }));
                        }
                    }
                }
            }
        }

        json!({
            "nodes": node_names,
            "channels": channel_names,
            "edges": edges_info,
            "entry_point": self.graph.entry,
        })
    }

    /// Build a PregelLoop from the graph structure
    ///
    /// This is a helper method that sets up the Pregel execution context
    /// including channels, node specs, and initial checkpoint.
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state
    ///
    /// # Returns
    ///
    /// PregelLoop ready for execution
    fn build_pregel_loop(
        &self,
        input: Value,
    ) -> Result<PregelLoop> {
        // 1. Create initial checkpoint
        let mut checkpoint = PregelCheckpoint::new();

        // 2. Build reverse edge map: node ‚Üí list of predecessors
        let mut incoming_edges: HashMap<String, Vec<String>> = HashMap::new();

        for (from_node, edges) in &self.graph.edges {
            for edge in edges {
                let to_node = match edge {
                    Edge::Direct(node_id) => node_id.clone(),
                    Edge::Conditional { .. } => {
                        // For conditional edges, DO NOT add to incoming_edges
                        // The conditional edge evaluation will handle routing dynamically
                        // at runtime based on the router function result
                        continue;
                    }
                };

                incoming_edges
                    .entry(to_node)
                    .or_default()
                    .push(from_node.clone());
            }
        }

        // 3. Create channels: one per node (represents that node's output)
        let mut channels: HashMap<String, Box<dyn Channel>> = HashMap::new();

        // Create START channel with initial input
        channels.insert(
            START.to_string(),
            Box::new(LastValueChannel::with_value(input.clone())),
        );
        checkpoint
            .channel_versions
            .insert(START.to_string(), ChannelVersion::Int(1));

        // Create channel for each regular node
        for node_id in self.graph.nodes.keys() {
            channels.insert(node_id.clone(), Box::new(LastValueChannel::new()));
        }

        // Create END channel
        channels.insert(END.to_string(), Box::new(LastValueChannel::new()));

        // Create TASKS channel for dynamic task spawning (Send objects)
        // This is a Topic channel that accumulates Send objects from nodes
        channels.insert(TASKS.to_string(), Box::new(TopicChannel::new()));

        // Create custom channels from graph.channels
        for (channel_name, channel_spec) in &self.graph.channels {
            // Skip if already created (e.g., node output channels)
            if channels.contains_key(channel_name) {
                continue;
            }

            // Create the appropriate channel type based on spec
            let channel: Box<dyn Channel> = if let Some(reducer) = &channel_spec.reducer {
                // If there's a reducer, use BinaryOperatorChannel regardless of type
                let reducer_clone = Arc::clone(reducer);
                Box::new(BinaryOperatorChannel::new(move |left, right| {
                    reducer_clone(left, right)
                }))
            } else {
                // No reducer - create based on type
                match channel_spec.channel_type {
                    crate::graph::ChannelType::LastValue => Box::new(LastValueChannel::new()),
                    crate::graph::ChannelType::Topic => Box::new(TopicChannel::new()),
                    crate::graph::ChannelType::BinaryOp => {
                        // BinaryOp without reducer doesn't make sense, but default to LastValue
                        Box::new(LastValueChannel::new())
                    }
                }
            };

            channels.insert(channel_name.clone(), channel);
        }

        // Initialize custom channels with values from input if present
        if let Some(input_obj) = input.as_object() {
            for (channel_name, channel_spec) in &self.graph.channels {
                if let Some(value) = input_obj.get(&channel_spec.name) {
                    if let Some(channel) = channels.get_mut(channel_name) {
                        // For channels with reducers that expect arrays (like add_messages),
                        // we need to bootstrap by setting empty array first, then merging the input
                        if channel_spec.reducer.is_some() && value.is_array() {
                            // First set empty array as initial value
                            let _ = channel.update(vec![serde_json::json!([])]);
                            // Then merge the input array using the reducer
                            let _ = channel.update(vec![value.clone()]);
                        } else {
                            // No reducer or not an array - just set the value directly
                            let _ = channel.update(vec![value.clone()]);
                        }
                        checkpoint
                            .channel_versions
                            .insert(channel_name.clone(), ChannelVersion::Int(1));
                    }
                }
            }
        }

        // 4. Convert graph nodes to Pregel node specs
        let mut pregel_nodes = HashMap::new();

        for (node_id, node_spec) in &self.graph.nodes {
            // Determine which channels trigger this node (its predecessors)
            let triggers = incoming_edges
                .get(node_id)
                .cloned()
                .unwrap_or_else(|| vec![START.to_string()]);

            // Wrap the existing executor in a Pregel-compatible adapter
            let executor_clone = node_spec.executor.clone();
            let edges_clone = self.graph.edges.get(node_id).cloned();

            let adapter = GraphExecutorAdapterWithEdges {
                executor: executor_clone,
                node_id: node_id.clone(),
                edges: edges_clone,
            };

            pregel_nodes.insert(
                node_id.clone(),
                PregelNodeSpec {
                    name: node_id.clone(),
                    triggers,
                    reads: node_spec.reads.clone(),
                    executor: Arc::new(adapter),
                },
            );
        }

        // 5. Create PregelLoop with edges for conditional routing
        let mut pregel_loop = PregelLoop::new_with_edges(
            checkpoint,
            channels,
            pregel_nodes,
            100,
            self.graph.edges.clone(),
        );

        // 6. Add store if available
        if let Some(store) = &self.store {
            pregel_loop = pregel_loop.with_store(store.clone());
        }

        Ok(pregel_loop)
    }

    /// Add batch execution method
    ///
    /// # Arguments
    ///
    /// * `inputs` - Vector of initial states
    ///
    /// # Returns
    ///
    /// Vector of final states after execution
    pub async fn batch(&self, inputs: Vec<Value>) -> Result<Vec<Value>> {
        self.batch_with_config(inputs, None).await
    }

    /// Add batch execution method with configuration
    ///
    /// # Arguments
    ///
    /// * `inputs` - Vector of initial states
    /// * `config` - Optional checkpoint configuration
    ///
    /// # Returns
    ///
    /// Vector of final states after execution
    pub async fn batch_with_config(
        &self,
        inputs: Vec<Value>,
        config: Option<CheckpointConfig>,
    ) -> Result<Vec<Value>> {
        // Execute all inputs in parallel
        let mut tasks = Vec::new();

        for input in inputs {
            let cfg = config.clone();
            let future = self.invoke_with_config(input, cfg);
            tasks.push(future);
        }

        // Wait for all tasks to complete
        let results = futures::future::join_all(tasks).await;

        // Collect results or return first error
        let mut outputs = Vec::new();
        for result in results {
            outputs.push(result?);
        }

        Ok(outputs)
    }

    /// Execute the graph using the Pregel algorithm (legacy method, use invoke() instead)
    ///
    /// This uses the proper superstep-based Pregel execution model with:
    /// - Version-based triggering
    /// - Barrier synchronization
    /// - Checkpoint support
    ///
    /// # Arguments
    ///
    /// * `input` - Initial state
    ///
    /// # Returns
    ///
    /// Final state after execution
    #[deprecated(note = "Use invoke() instead, which now uses Pregel execution")]
    pub async fn invoke_pregel(&self, input: Value) -> Result<Value> {
        // 1. Create initial checkpoint
        let mut checkpoint = PregelCheckpoint::new();

        // 2. Build reverse edge map: node ‚Üí list of predecessors
        let mut incoming_edges: HashMap<String, Vec<String>> = HashMap::new();

        for (from_node, edges) in &self.graph.edges {
            for edge in edges {
                let to_node = match edge {
                    Edge::Direct(node_id) => node_id.clone(),
                    Edge::Conditional { .. } => {
                        // For conditional edges, DO NOT add to incoming_edges
                        // The conditional edge evaluation will handle routing dynamically
                        // at runtime based on the router function result
                        continue;
                    }
                };

                incoming_edges
                    .entry(to_node)
                    .or_default()
                    .push(from_node.clone());
            }
        }

        // 3. Create channels: one per node (represents that node's output)
        let mut channels: HashMap<String, Box<dyn Channel>> = HashMap::new();

        // Create START channel with initial input
        channels.insert(START.to_string(), Box::new(LastValueChannel::with_value(input.clone())));
        checkpoint
            .channel_versions
            .insert(START.to_string(), ChannelVersion::Int(1));

        // Create channel for each regular node
        for node_id in self.graph.nodes.keys() {
            channels.insert(node_id.clone(), Box::new(LastValueChannel::new()));
        }

        // Create END channel
        channels.insert(END.to_string(), Box::new(LastValueChannel::new()));

        // 4. Convert graph nodes to Pregel node specs
        let mut pregel_nodes = HashMap::new();

        for (node_id, node_spec) in &self.graph.nodes {
            // Determine which channels trigger this node (its predecessors)
            let triggers = incoming_edges
                .get(node_id)
                .cloned()
                .unwrap_or_else(|| vec![START.to_string()]);

            // Wrap the existing executor in a Pregel-compatible adapter
            let executor_clone = node_spec.executor.clone();
            let edges_clone = self.graph.edges.get(node_id).cloned();

            let adapter = GraphExecutorAdapterWithEdges {
                executor: executor_clone,
                node_id: node_id.clone(),
                edges: edges_clone,
            };

            pregel_nodes.insert(
                node_id.clone(),
                PregelNodeSpec {
                    name: node_id.clone(),
                    triggers,
                    reads: node_spec.reads.clone(),
                    executor: Arc::new(adapter),
                },
            );
        }

        // 5. Create and run Pregel loop (without executed_nodes tracking)
        let mut pregel_loop = PregelLoop::new_with_edges(
            checkpoint,
            channels,
            pregel_nodes,
            100,
            self.graph.edges.clone(),
        );

        let result = pregel_loop.run().await?;

        // 6. Extract final state from result
        Ok(result)
    }
}

/// Convert StreamEvent to ExecutionEvent
fn convert_stream_event(event: crate::stream::StreamEvent) -> ExecutionEvent {
    use crate::stream::StreamEvent as SE;

    match event {
        SE::TaskStart { node, .. } => ExecutionEvent::NodeStart { node },
        SE::TaskEnd { node, output, .. } => ExecutionEvent::NodeEnd { node, output },
        SE::TaskError { node, error, .. } => ExecutionEvent::Error { node, error },
        SE::Values { state } => ExecutionEvent::StateUpdate { state },
        SE::Updates { node, update } => ExecutionEvent::NodeEnd {
            node,
            output: update,
        },
        SE::Checkpoint { .. } => {
            // For now, map checkpoint events to state updates
            // In a full implementation, we might want to add a Checkpoint variant to ExecutionEvent
            ExecutionEvent::StateUpdate {
                state: serde_json::json!({"checkpoint": "saved"}),
            }
        }
        SE::Message { message, .. } => ExecutionEvent::StateUpdate {
            state: serde_json::json!({"message": message}),
        },
        SE::MessageChunk { chunk, node, .. } => ExecutionEvent::StateUpdate {
            state: serde_json::json!({"chunk": chunk, "node": node}),
        },
        SE::Custom { data } => ExecutionEvent::StateUpdate {
            state: serde_json::json!({"custom": data}),
        },
    }
}

/// Adapter to wrap existing graph node executors for Pregel execution
/// This adapter knows about outgoing edges and writes to successor channels
struct GraphExecutorAdapterWithEdges {
    executor: GraphNodeExecutor,
    node_id: String,
    edges: Option<Vec<Edge>>,
}

impl NodeExecutor for GraphExecutorAdapterWithEdges {
    fn execute(
        &self,
        input: Value,
    ) -> Pin<Box<dyn std::future::Future<Output = Result<Value>> + Send + '_>> {
        let executor = self.executor.clone();
        let _edges = self.edges.clone();

        Box::pin(async move {
            // Execute the node
            let result = executor(input)
                .await
                .map_err(|e| GraphError::Execution(e.to_string()))?;

            // The result will be written to this node's channel by the loop
            // Edges are stored in the adapter for future use
            // TODO: Handle conditional routing - evaluate router function and write to appropriate channel

            Ok(result)
        })
    }
}

impl std::fmt::Debug for CompiledGraph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("CompiledGraph")
            .field("graph", &self.graph)
            .field("has_checkpointer", &self.checkpoint_saver.is_some())
            .field("interrupt_config", &self.interrupt_config)
            .finish()
    }
}

/// Implement SubgraphExecutor for CompiledGraph
/// This allows compiled graphs to be used as subgraphs in parent graphs
impl SubgraphExecutor for CompiledGraph {
    fn invoke(
        &self,
        state: Value,
    ) -> Pin<Box<dyn std::future::Future<Output = std::result::Result<Value, Box<dyn std::error::Error + Send + Sync>>> + Send>> {
        // Clone self to move into the future
        let graph = self.clone();
        Box::pin(async move {
            graph.invoke(state)
                .await
                .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send + Sync>)
        })
    }

    fn name(&self) -> &str {
        "subgraph"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::builder::StateGraph;

    #[tokio::test]
    async fn test_simple_execution() {
        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({
            "value": 42
        });

        let output = compiled.invoke(input).await.unwrap();

        assert_eq!(output["value"], 42);
        assert_eq!(output["processed"], true);
    }

    #[tokio::test]
    async fn test_conditional_execution() {
        let mut builder = StateGraph::new();

        builder.add_node("router", |state| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_node("path_a", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("path".to_string(), serde_json::json!("a"));
                }
                Ok(state)
            })
        });

        builder.add_node("path_b", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("path".to_string(), serde_json::json!("b"));
                }
                Ok(state)
            })
        });

        let mut branches = HashMap::new();
        branches.insert("a".to_string(), "path_a".to_string());
        branches.insert("b".to_string(), "path_b".to_string());

        builder.add_edge("__start__", "router");
        builder.add_conditional_edge(
            "router",
            |state| {
                use crate::send::ConditionalEdgeResult;
                if let Some(choice) = state.get("choice").and_then(|v| v.as_str()) {
                    if choice == "a" {
                        return ConditionalEdgeResult::Node("path_a".to_string());
                    }
                }
                ConditionalEdgeResult::Node("path_b".to_string())
            },
            branches,
        );

        builder.add_finish("path_a");
        builder.add_finish("path_b");

        let compiled = builder.compile().unwrap();

        // Test path A
        let input_a = serde_json::json!({
            "choice": "a"
        });
        let output_a = compiled.invoke(input_a).await.unwrap();
        assert_eq!(output_a["path"], "a");

        // Test path B
        let input_b = serde_json::json!({
            "choice": "b"
        });
        let output_b = compiled.invoke(input_b).await.unwrap();
        assert_eq!(output_b["path"], "b");
    }

    #[tokio::test]
    async fn test_pregel_execution() {
        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                    let value = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("result".to_string(), serde_json::json!(value * 2));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({
            "value": 21
        });

        // Test the new Pregel execution
        let output = compiled.invoke_pregel(input).await.unwrap();

        // The output from Pregel loop includes step and channel_versions
        // In a full implementation, we would extract the final state properly
        assert!(output.is_object());
        println!("Pregel output: {}", output);
    }

    #[tokio::test]
    async fn test_pregel_graph_topology() {
        // Test that graph topology is properly respected
        // Graph: START ‚Üí node1 ‚Üí node2 ‚Üí END
        let mut builder = StateGraph::new();

        builder.add_node("node1", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("node1_ran".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_node("node2", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("node2_ran".to_string(), serde_json::json!(true));
                    // Verify node1 already ran
                    assert_eq!(obj.get("node1_ran"), Some(&serde_json::json!(true)),
                        "node2 should run after node1");
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "node1");
        builder.add_edge("node1", "node2");
        builder.add_edge("node2", "__end__");

        let compiled = builder.compile().unwrap();
        let input = serde_json::json!({"initial": true});

        let output = compiled.invoke_pregel(input).await.unwrap();

        // Verify both nodes ran
        assert_eq!(output.get("node1_ran"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("node2_ran"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("initial"), Some(&serde_json::json!(true)));
    }

    // ===== HIGH-LEVEL API INTEGRATION TESTS =====

    #[tokio::test]
    async fn test_invoke_uses_pregel() {
        // Test that invoke() now uses the Pregel execution engine
        let mut builder = StateGraph::new();

        builder.add_node("step1", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("step1".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_node("step2", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("step2".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "step1");
        builder.add_edge("step1", "step2");
        builder.add_edge("step2", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({"initial": "value"});
        let output = compiled.invoke(input).await.unwrap();

        // Verify both steps executed
        assert_eq!(output.get("step1"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("step2"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("initial"), Some(&serde_json::json!("value")));
    }

    #[tokio::test]
    async fn test_batch_execution() {
        // Test batch() method executes multiple inputs
        let mut builder = StateGraph::new();

        builder.add_node("multiply", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    if let Some(val) = obj.get("value").and_then(|v| v.as_i64()) {
                        obj.insert("result".to_string(), serde_json::json!(val * 2));
                    }
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "multiply");
        builder.add_edge("multiply", "__end__");

        let compiled = builder.compile().unwrap();

        let inputs = vec![
            serde_json::json!({"value": 1}),
            serde_json::json!({"value": 2}),
            serde_json::json!({"value": 3}),
        ];

        let outputs = compiled.batch(inputs).await.unwrap();

        assert_eq!(outputs.len(), 3);
        assert_eq!(outputs[0].get("result"), Some(&serde_json::json!(2)));
        assert_eq!(outputs[1].get("result"), Some(&serde_json::json!(4)));
        assert_eq!(outputs[2].get("result"), Some(&serde_json::json!(6)));
    }

    #[tokio::test]
    async fn test_stream_basic() {
        // Test stream() method emits events
        use futures::stream::StreamExt;

        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({"input": "data"});
        let mut stream = compiled.stream(input).await.unwrap();

        // Collect all events
        let mut events = Vec::new();
        while let Some(event) = stream.next().await {
            events.push(event);
        }

        // Should have at least one event
        assert!(!events.is_empty(), "Stream should emit events");
    }

    #[tokio::test]
    async fn test_stream_with_multiple_modes() {
        // Test stream_with_modes() with Tasks and Updates modes
        use futures::stream::StreamExt;
        use crate::stream::StreamMode;

        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({"input": "data"});
        let mut stream = compiled
            .stream_with_modes(input, vec![StreamMode::Tasks, StreamMode::Updates], None)
            .await
            .unwrap();

        // Collect all events
        let mut events = Vec::new();
        while let Some(event) = stream.next().await {
            events.push(event);
        }

        // Should have task and update events
        assert!(!events.is_empty(), "Stream should emit events");

        // Check that we have NodeStart and NodeEnd events
        let has_node_start = events.iter().any(|e| matches!(e, ExecutionEvent::NodeStart { .. }));
        let has_node_end = events.iter().any(|e| matches!(e, ExecutionEvent::NodeEnd { .. }));

        assert!(has_node_start || has_node_end, "Should have node execution events");
    }

    #[tokio::test]
    async fn test_invoke_with_multiple_nodes() {
        // Test invoke() with a more complex graph
        let mut builder = StateGraph::new();

        builder.add_node("step1", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let count = obj.get("count").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("count".to_string(), serde_json::json!(count + 1));
                }
                Ok(state)
            })
        });

        builder.add_node("step2", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let count = obj.get("count").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("count".to_string(), serde_json::json!(count + 1));
                }
                Ok(state)
            })
        });

        builder.add_node("step3", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let count = obj.get("count").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("count".to_string(), serde_json::json!(count + 1));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "step1");
        builder.add_edge("step1", "step2");
        builder.add_edge("step2", "step3");
        builder.add_edge("step3", "__end__");

        let compiled = builder.compile().unwrap();

        let input = serde_json::json!({"count": 0});
        let output = compiled.invoke(input).await.unwrap();

        // All three steps should have incremented the count
        assert_eq!(output.get("count"), Some(&serde_json::json!(3)));
    }

    #[tokio::test]
    async fn test_batch_preserves_independence() {
        // Test that batch executions are independent
        let mut builder = StateGraph::new();

        builder.add_node("increment", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    if let Some(val) = obj.get("value").and_then(|v| v.as_i64()) {
                        obj.insert("value".to_string(), serde_json::json!(val + 1));
                    }
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "increment");
        builder.add_edge("increment", "__end__");

        let compiled = builder.compile().unwrap();

        let inputs = vec![
            serde_json::json!({"value": 10}),
            serde_json::json!({"value": 20}),
            serde_json::json!({"value": 30}),
        ];

        let outputs = compiled.batch(inputs).await.unwrap();

        // Each output should be independent
        assert_eq!(outputs[0].get("value"), Some(&serde_json::json!(11)));
        assert_eq!(outputs[1].get("value"), Some(&serde_json::json!(21)));
        assert_eq!(outputs[2].get("value"), Some(&serde_json::json!(31)));
    }

    #[tokio::test]
    async fn test_invoke_with_checkpointer() {
        use langgraph_checkpoint::InMemoryCheckpointSaver;

        // Test invoke_with_config using a checkpointer
        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let saver = Arc::new(InMemoryCheckpointSaver::new());
        let compiled = builder.compile().unwrap().with_checkpointer(saver.clone());

        let config = CheckpointConfig {
            thread_id: Some("test-thread".to_string()),
            checkpoint_id: None,
            checkpoint_ns: None,
            extra: HashMap::new(),
        };

        let input = serde_json::json!({"value": 42});
        let output = compiled.invoke_with_config(input, Some(config.clone())).await.unwrap();

        assert_eq!(output.get("processed"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("value"), Some(&serde_json::json!(42)));

        // Verify checkpoint was saved using get_tuple
        let tuple = saver.get_tuple(&config).await.unwrap();
        assert!(tuple.is_some(), "Checkpoint should have been saved");
    }

    // ===== FUNCTIONAL COMPOSITION TESTS =====

    #[tokio::test]
    async fn test_then_sequential_composition() {
        // Create first graph that adds 1
        let mut first = StateGraph::new();
        first.add_node("add_one", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val + 1));
                }
                Ok(state)
            })
        });
        first.add_edge("__start__", "add_one");
        first.add_edge("add_one", "__end__");

        // Create second graph that multiplies by 2
        let mut second = StateGraph::new();
        second.add_node("multiply", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val * 2));
                }
                Ok(state)
            })
        });
        second.add_edge("__start__", "multiply");
        second.add_edge("multiply", "__end__");

        // Compose them: first then second
        let composed = first.compile().unwrap().then(second.compile().unwrap());

        // Execute: 5 + 1 = 6, then 6 * 2 = 12
        let input = serde_json::json!({"value": 5});
        let output = composed.invoke(input).await.unwrap();

        assert_eq!(output.get("value"), Some(&serde_json::json!(12)));
    }

    #[tokio::test]
    async fn test_map_transformation() {
        // Create a simple graph
        let mut graph = StateGraph::new();
        graph.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });
        graph.add_edge("__start__", "process");
        graph.add_edge("process", "__end__");

        // Apply map transformation
        let mapped = graph.compile().unwrap().map(|mut output| {
            Box::pin(async move {
                if let Some(obj) = output.as_object_mut() {
                    obj.insert("transformed".to_string(), serde_json::json!(true));
                    let count = obj.get("count").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("count".to_string(), serde_json::json!(count + 10));
                }
                Ok(output)
            })
        });

        let input = serde_json::json!({"count": 5});
        let output = mapped.invoke(input).await.unwrap();

        assert_eq!(output.get("processed"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("transformed"), Some(&serde_json::json!(true)));
        assert_eq!(output.get("count"), Some(&serde_json::json!(15)));
    }

    #[tokio::test]
    async fn test_chain_multiple_graphs() {
        // Create three graphs that each add 1
        let mut graphs = Vec::new();

        for _ in 0..3 {
            let mut graph = StateGraph::new();
            graph.add_node("increment", |mut state: Value| {
                Box::pin(async move {
                    if let Some(obj) = state.as_object_mut() {
                        let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                        obj.insert("value".to_string(), serde_json::json!(val + 1));
                    }
                    Ok(state)
                })
            });
            graph.add_edge("__start__", "increment");
            graph.add_edge("increment", "__end__");
            graphs.push(graph.compile().unwrap());
        }

        // Chain all three
        let chained = CompiledGraph::chain(graphs).unwrap();

        // Execute: 10 + 1 + 1 + 1 = 13
        let input = serde_json::json!({"value": 10});
        let output = chained.invoke(input).await.unwrap();

        assert_eq!(output.get("value"), Some(&serde_json::json!(13)));
    }

    #[tokio::test]
    async fn test_chain_empty_list() {
        let result = CompiledGraph::chain(vec![]);
        assert!(result.is_err(), "Chaining empty list should fail");
    }

    #[tokio::test]
    async fn test_chain_single_graph() {
        let mut graph = StateGraph::new();
        graph.add_node("process", |state| {
            Box::pin(async move { Ok(state) })
        });
        graph.add_edge("__start__", "process");
        graph.add_edge("process", "__end__");

        let compiled = graph.compile().unwrap();
        let chained = CompiledGraph::chain(vec![compiled]).unwrap();

        let input = serde_json::json!({"value": 42});
        let output = chained.invoke(input).await.unwrap();

        assert_eq!(output.get("value"), Some(&serde_json::json!(42)));
    }

    #[tokio::test]
    #[ignore = "Conditional edges not yet supported in Pregel execution"]
    async fn test_when_conditional_true() {
        // Create a graph that adds 10
        let mut graph = StateGraph::new();
        graph.add_node("add_ten", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val + 10));
                    obj.insert("executed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });
        graph.add_edge("__start__", "add_ten");
        graph.add_edge("add_ten", "__end__");

        // Only execute if "enabled" is true
        let conditional = graph.compile().unwrap().when(|state| {
            state.get("enabled")
                .and_then(|v| v.as_bool())
                .unwrap_or(false)
        });

        // Test with enabled = true
        let input = serde_json::json!({"value": 5, "enabled": true});
        let output = conditional.invoke(input).await.unwrap();

        assert_eq!(output.get("value"), Some(&serde_json::json!(15)));
        assert_eq!(output.get("executed"), Some(&serde_json::json!(true)));
    }

    #[tokio::test]
    #[ignore = "Conditional edges not yet supported in Pregel execution"]
    async fn test_when_conditional_false() {
        // Create a graph that adds 10
        let mut graph = StateGraph::new();
        graph.add_node("add_ten", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val + 10));
                    obj.insert("executed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });
        graph.add_edge("__start__", "add_ten");
        graph.add_edge("add_ten", "__end__");

        // Only execute if "enabled" is true
        let conditional = graph.compile().unwrap().when(|state| {
            state.get("enabled")
                .and_then(|v| v.as_bool())
                .unwrap_or(false)
        });

        // Test with enabled = false
        let input = serde_json::json!({"value": 5, "enabled": false});
        let output = conditional.invoke(input).await.unwrap();

        // Value should be unchanged
        assert_eq!(output.get("value"), Some(&serde_json::json!(5)));
        // executed flag should not be present
        assert_eq!(output.get("executed"), None);
    }

    #[tokio::test]
    #[ignore = "Conditional edges (when) not yet supported in Pregel execution"]
    async fn test_complex_composition() {
        // Build a complex composition: (graph1 then graph2).map(transform).when(predicate)

        // Graph 1: double the value
        let mut graph1 = StateGraph::new();
        graph1.add_node("double", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val * 2));
                }
                Ok(state)
            })
        });
        graph1.add_edge("__start__", "double");
        graph1.add_edge("double", "__end__");

        // Graph 2: add 5
        let mut graph2 = StateGraph::new();
        graph2.add_node("add_five", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                    obj.insert("value".to_string(), serde_json::json!(val + 5));
                }
                Ok(state)
            })
        });
        graph2.add_edge("__start__", "add_five");
        graph2.add_edge("add_five", "__end__");

        // Compose: graph1 -> graph2 -> map(square) -> when(value > 10)
        let composed = graph1.compile().unwrap()
            .then(graph2.compile().unwrap())
            .map(|mut output| {
                Box::pin(async move {
                    if let Some(obj) = output.as_object_mut() {
                        let val = obj.get("value").and_then(|v| v.as_i64()).unwrap_or(0);
                        obj.insert("value".to_string(), serde_json::json!(val * val)); // square
                    }
                    Ok(output)
                })
            })
            .when(|state| {
                state.get("value")
                    .and_then(|v| v.as_i64())
                    .map(|v| v > 10)
                    .unwrap_or(false)
            });

        // Test case 1: value starts at 3
        // 3 * 2 = 6, 6 + 5 = 11, 11^2 = 121, condition true -> executes
        let input1 = serde_json::json!({"value": 3});
        let output1 = composed.invoke(input1).await.unwrap();
        assert_eq!(output1.get("value"), Some(&serde_json::json!(121)));

        // Test case 2: value starts at 1
        // 1 * 2 = 2, 2 + 5 = 7, 7^2 = 49, condition true -> executes
        let input2 = serde_json::json!({"value": 1});
        let output2 = composed.invoke(input2).await.unwrap();
        assert_eq!(output2.get("value"), Some(&serde_json::json!(49)));
    }

    #[tokio::test]
    async fn test_tasks_channel_creation() {
        // Verify that TASKS channel is automatically created during compilation
        // The channel is created as a Topic channel in build_pregel_loop()
        let mut builder = StateGraph::new();

        builder.add_node("process", |mut state: Value| {
            Box::pin(async move {
                if let Some(obj) = state.as_object_mut() {
                    obj.insert("processed".to_string(), serde_json::json!(true));
                }
                Ok(state)
            })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        // Verify the TASKS constant is correct
        assert_eq!(TASKS, "__tasks__");

        let input = serde_json::json!({
            "value": 42
        });

        // Run the graph to ensure TASKS channel was created and doesn't interfere
        // with normal execution. The TASKS channel is created internally in build_pregel_loop()
        let output = compiled.invoke(input).await.unwrap();

        assert_eq!(output["value"], 42);
        assert_eq!(output["processed"], true);

        // If we reach this point, TASKS channel was successfully created and
        // the graph executed normally. TASKS is now available for nodes to
        // write Send objects to for dynamic task spawning.
    }

    #[tokio::test]
    async fn test_get_input_schema() {
        let mut builder = StateGraph::new();

        builder.add_node("process", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let schema = compiled.get_input_schema();

        // Should have type "object"
        assert_eq!(schema["type"], "object");

        // Should have description
        assert!(schema["description"].is_string());

        // For a simple StateGraph with no custom channels, should allow additional properties
        assert_eq!(schema["additionalProperties"], true);
    }

    #[tokio::test]
    async fn test_get_output_schema() {
        let mut builder = StateGraph::new();

        builder.add_node("process", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let schema = compiled.get_output_schema();

        // Should have type "object"
        assert_eq!(schema["type"], "object");

        // Should have description
        assert!(schema["description"].is_string());
    }

    #[tokio::test]
    async fn test_get_channels() {
        let mut builder = StateGraph::new();

        builder.add_node("node1", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_node("node2", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "node1");
        builder.add_edge("node1", "node2");
        builder.add_edge("node2", "__end__");

        let compiled = builder.compile().unwrap();

        let channels = compiled.get_channels();

        // Should not include internal channels like __start__
        assert!(!channels.contains(&"__start__".to_string()));

        // Should not include internal channels like __tasks__
        assert!(!channels.contains(&"__tasks__".to_string()));

        // For a simple StateGraph with only node channels, get_channels() may return empty
        // This is correct behavior - node output channels are filtered out
        // A MessageGraph would have a "messages" channel
    }

    #[tokio::test]
    async fn test_get_metadata() {
        let mut builder = StateGraph::new();

        builder.add_node("node1", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_node("node2", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "node1");
        builder.add_edge("node1", "node2");
        builder.add_edge("node2", "__end__");

        let compiled = builder.compile().unwrap();

        let metadata = compiled.get_metadata();

        // Should have nodes array
        assert!(metadata["nodes"].is_array());
        let nodes = metadata["nodes"].as_array().unwrap();
        assert!(nodes.len() >= 2);

        // Should have channels array
        assert!(metadata["channels"].is_array());

        // Should have edges array
        assert!(metadata["edges"].is_array());
        let edges = metadata["edges"].as_array().unwrap();
        assert!(edges.len() >= 2); // At least __start__->node1 and node1->node2

        // Should have entry_point
        assert!(metadata["entry_point"].is_string());
    }

    #[tokio::test]
    async fn test_get_metadata_with_conditional_edges() {
        let mut builder = StateGraph::new();

        builder.add_node("router", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_node("path_a", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_node("path_b", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        let mut branches = HashMap::new();
        branches.insert("a".to_string(), "path_a".to_string());
        branches.insert("b".to_string(), "path_b".to_string());

        builder.add_edge("__start__", "router");
        builder.add_conditional_edge(
            "router",
            |state| {
                use crate::send::ConditionalEdgeResult;
                if let Some(choice) = state.get("choice").and_then(|v| v.as_str()) {
                    if choice == "a" {
                        return ConditionalEdgeResult::Node("path_a".to_string());
                    }
                }
                ConditionalEdgeResult::Node("path_b".to_string())
            },
            branches,
        );

        builder.add_finish("path_a");
        builder.add_finish("path_b");

        let compiled = builder.compile().unwrap();

        let metadata = compiled.get_metadata();

        // Should have edges array with conditional edges
        assert!(metadata["edges"].is_array());
        let edges = metadata["edges"].as_array().unwrap();

        // Find conditional edges
        let conditional_edges: Vec<_> = edges.iter()
            .filter(|e| e["type"] == "conditional")
            .collect();

        assert!(!conditional_edges.is_empty(), "Should have at least one conditional edge");

        // Verify conditional edge structure
        let cond_edge = &conditional_edges[0];
        assert_eq!(cond_edge["type"], "conditional");
        assert_eq!(cond_edge["from"], "router");
        assert!(cond_edge["to"].is_string());
        assert!(cond_edge["path"].is_string());
    }

    #[tokio::test]
    async fn test_schema_with_message_graph() {
        use crate::MessageGraph;

        let mut builder = MessageGraph::new();

        builder.add_node("chat", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "chat");
        builder.add_edge("chat", "__end__");

        let compiled = builder.compile().unwrap();

        // MessageGraph should have a "messages" channel
        let channels = compiled.get_channels();
        assert!(channels.contains(&"messages".to_string()),
            "MessageGraph should have messages channel, got: {:?}", channels);

        // Input schema should include messages property
        let input_schema = compiled.get_input_schema();
        assert!(input_schema["properties"].is_object());
        let properties = input_schema["properties"].as_object().unwrap();
        assert!(properties.contains_key("messages"),
            "Input schema should have messages property");

        // Metadata should show the message graph structure
        let metadata = compiled.get_metadata();
        assert!(metadata["nodes"].is_array());
        assert!(metadata["channels"].as_array().unwrap().contains(&serde_json::json!("messages")));
    }

    #[tokio::test]
    async fn test_stream_channels_list_basic() {
        let mut builder = StateGraph::new();

        builder.add_node("process", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "process");
        builder.add_edge("process", "__end__");

        let compiled = builder.compile().unwrap();

        let streamable = compiled.stream_channels_list();

        // Should not include internal channels
        assert!(!streamable.contains(&"__start__".to_string()));
        assert!(!streamable.contains(&"__tasks__".to_string()));
        assert!(!streamable.contains(&"__end__".to_string()));

        // Should not include node output channels
        assert!(!streamable.contains(&"process".to_string()));
    }

    #[tokio::test]
    async fn test_stream_channels_list_with_message_graph() {
        use crate::MessageGraph;

        let mut builder = MessageGraph::new();

        builder.add_node("chat", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "chat");
        builder.add_edge("chat", "__end__");

        let compiled = builder.compile().unwrap();

        let streamable = compiled.stream_channels_list();

        // MessageGraph should have "messages" channel available for streaming
        assert!(streamable.contains(&"messages".to_string()),
            "MessageGraph should have messages channel streamable, got: {:?}", streamable);

        // Should not include internal channels
        assert!(!streamable.contains(&"__start__".to_string()));
        assert!(!streamable.contains(&"__tasks__".to_string()));
    }

    #[tokio::test]
    async fn test_stream_channels_list_matches_get_channels() {
        use crate::MessageGraph;

        let mut builder = MessageGraph::new();

        builder.add_node("chat", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "chat");
        builder.add_edge("chat", "__end__");

        let compiled = builder.compile().unwrap();

        // For now, stream_channels_list() should return the same as get_channels()
        // Both filter out internal and node output channels
        let channels = compiled.get_channels();
        let streamable = compiled.stream_channels_list();

        // Sort both for comparison
        let mut channels_sorted = channels.clone();
        let mut streamable_sorted = streamable.clone();
        channels_sorted.sort();
        streamable_sorted.sort();

        // They should be identical for now (until we add stream_channels config)
        assert_eq!(channels_sorted, streamable_sorted,
            "get_channels() and stream_channels_list() should return the same channels for now");
    }

    #[tokio::test]
    async fn test_stream_channels_list_empty_for_simple_graph() {
        let mut builder = StateGraph::new();

        builder.add_node("node1", |state: Value| {
            Box::pin(async move { Ok(state) })
        });

        builder.add_edge("__start__", "node1");
        builder.add_edge("node1", "__end__");

        let compiled = builder.compile().unwrap();

        let streamable = compiled.stream_channels_list();

        // For a simple StateGraph with only node channels, should be empty
        // (all channels are either internal or node outputs)
        // This is correct behavior - no user-defined channels to stream
        assert!(streamable.is_empty() || streamable.len() == 0,
            "Simple StateGraph with only node channels should have no streamable channels");
    }
}
