# Plan-Execute Pattern Configuration Template
# Plan-Execute: Plan first, then execute the plan
# Pattern: Plan (create steps) → Execute step 1 → Execute step 2 → ... → Replan (if needed)

name: plan_execute
type: plan_execute
description: Plan first, then execute plan systematically

# Pattern Overview
# The Plan-Execute pattern separates planning from execution. First, a planner
# creates a detailed step-by-step plan. Then, an executor carries out each step
# sequentially. If something goes wrong, the planner can create a new plan.

# When to Use Plan-Execute
# - Well-defined tasks with clear goals
# - Multi-step implementations
# - Complex workflows requiring coordination
# - Tasks where upfront planning saves time
# - When steps have dependencies
# - Structured problem-solving

# Configuration
config:
  # Maximum number of steps in the plan
  max_steps: 15

  # Enable replanning if plan fails
  replanning_enabled: true

  # Maximum number of replanning attempts
  max_replans: 2

  # Planning LLM Configuration
  # Uses a more creative LLM for planning
  planner_config:
    model: "gpt-4"  # Or: claude-3-sonnet, deepseek-r1
    temperature: 0.7  # Higher creativity for planning
    max_tokens: 4000  # Enough for detailed plans

  # Execution LLM Configuration
  # Uses a more deterministic LLM for execution
  executor_config:
    model: "gpt-4"  # Or: claude-3-haiku, llama3
    temperature: 0.5  # Lower for precise execution
    max_tokens: 2000  # Tool calls are shorter

  # Tools available for execution
  tools:
    - file_read
    - file_write
    - file_patch
    - grep
    - shell_exec

# System Prompts
prompts:
  # Planner system prompt
  planning: |
    You are a planning expert. Create a detailed, step-by-step plan to accomplish: {query}

    Your plan should:
    1. Break the task into clear, actionable steps
    2. Specify which tools to use for each step
    3. Consider dependencies between steps
    4. Anticipate potential issues
    5. Be comprehensive but not overly complex

    Output a structured plan with:
    - Step number
    - Action description
    - Tool(s) to use
    - Expected outcome
    - Dependencies on previous steps

    Aim for 5-12 steps for most tasks.

  # Executor system prompt
  execution: |
    You are executing step {step_number} of a plan.

    Step: {step_description}
    Tools available: {tools}
    Previous results: {context}

    Execute this step precisely:
    1. Use the specified tool(s)
    2. Follow the step description exactly
    3. Report results clearly
    4. Indicate success or failure

    If the step cannot be completed, explain why.

  # Replanning system prompt
  replanning: |
    The original plan failed at step {failed_step}.

    Original plan: {original_plan}
    Failure reason: {failure_reason}
    Progress so far: {completed_steps}

    Create a new plan to complete the task considering:
    1. What has already been accomplished
    2. Why the original plan failed
    3. Alternative approaches
    4. Remaining work needed

# Example Plan-Execute Cycle
example:
  task: "Add authentication to the user API endpoint"

  planning_phase:
    plan:
      - step: 1
        action: "Read current user API implementation"
        tool: "file_read"
        target: "src/api/user.rs"
        expected: "Understand current implementation"

      - step: 2
        action: "Search for existing auth patterns"
        tool: "grep"
        pattern: "authenticate"
        expected: "Find auth examples to follow"

      - step: 3
        action: "Create auth middleware function"
        tool: "file_patch"
        target: "src/api/user.rs"
        expected: "Auth function added"

      - step: 4
        action: "Apply middleware to endpoints"
        tool: "file_patch"
        target: "src/api/user.rs"
        expected: "Endpoints protected"

      - step: 5
        action: "Run tests"
        tool: "shell_exec"
        command: "cargo test api::user"
        expected: "Tests pass"

  execution_phase:
    step_1: "Success - read user.rs, found 3 endpoints"
    step_2: "Success - found auth pattern in src/auth/middleware.rs"
    step_3: "Success - created authenticate_user function"
    step_4: "Success - wrapped endpoints with auth check"
    step_5: "Success - all tests passing"

  result: "Task completed successfully in 5 steps"

# Performance Characteristics
performance:
  speed: "medium"  # Planning overhead + execution
  latency: "medium"  # 2-20 LLM calls depending on plan size
  flexibility: "medium"  # Can replan, but more structured than ReAct
  quality: "high"  # Organized approach yields good results

# Use Cases
use_cases:
  - name: "Feature implementation"
    description: "Adding new features with multiple components"
    typical_steps: "8-15"

  - name: "Refactoring"
    description: "Restructuring code across multiple files"
    typical_steps: "6-12"

  - name: "Bug fixing (complex)"
    description: "Fixing bugs requiring changes in multiple places"
    typical_steps: "5-10"

  - name: "Documentation generation"
    description: "Creating comprehensive documentation"
    typical_steps: "4-8"

  - name: "Test suite creation"
    description: "Adding tests for a module"
    typical_steps: "6-12"

# Best Practices
best_practices:
  - "Let the planner create detailed steps - don't micromanage"
  - "Each step should be independently verifiable"
  - "Include verification steps (build, test) in the plan"
  - "Use replanning when unexpected issues arise"
  - "Keep steps atomic - each should do one thing"
  - "Consider dependencies - later steps may need earlier results"

# Common Pitfalls
pitfalls:
  - "Plans that are too detailed (over-planning)"
  - "Plans that are too vague (under-planning)"
  - "Not enabling replanning when task is complex"
  - "Executor deviating from the plan"
  - "Not including verification steps"

# Optimization Tips
optimization:
  - "Use higher temperature (0.7-0.8) for creative planning"
  - "Use lower temperature (0.3-0.5) for precise execution"
  - "Set max_steps based on task: simple=5-8, complex=10-15"
  - "Enable replanning for unpredictable tasks"
  - "Different models for planner vs executor can improve quality"

# When Replanning is Needed
replanning_triggers:
  - "Step fails unexpectedly"
  - "Assumptions in plan were incorrect"
  - "New information changes the approach"
  - "Better approach discovered during execution"
  - "External dependencies changed"

# Comparison with Other Patterns
vs_react: |
  Plan-Execute is better when:
  - Task scope is well-defined
  - Multiple steps need coordination
  - Planning ahead saves iteration time
  - Systematic approach is important

  ReAct is better when:
  - Task scope is uncertain
  - Exploration is needed
  - Quick iterations matter more than planning
  - Flexibility is critical

vs_reflection: |
  Plan-Execute is better when:
  - Focus is on completing tasks rather than perfecting output
  - Steps are procedural rather than creative
  - Speed matters more than quality refinement

  Reflection is better when:
  - Output quality is paramount
  - Self-critique adds value
  - Iterative refinement improves results
