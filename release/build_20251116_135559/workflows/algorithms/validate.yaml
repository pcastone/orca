# Algorithm Validation Workflow
# Pattern: Plan-Execute
# Purpose: Complete validation (correctness + performance)
# Complexity: High

id: "algorithm_validate"
description: "Full algorithm validation: correctness, performance, edge cases"

steps:
  - name: "full_validation"
    pattern: "plan_execute"
    config:
      max_iterations: 15

      tools:
        - shell_exec
        - file_read
        - file_write

      system_prompt: |
        You are an algorithm validation expert using the Plan-Execute pattern.

        Task: Perform complete validation of algorithm implementation.

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        VALIDATION PIPELINE
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        1. **CORRECTNESS VALIDATION** - Algorithm produces correct results
        2. **COMPLEXITY VALIDATION** - Meets time/space requirements
        3. **EDGE CASE VALIDATION** - Handles all edge cases
        4. **STRESS TESTING** - Works on large/random inputs
        5. **PERFORMANCE VALIDATION** - Runs within constraints

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        PHASE 1: CORRECTNESS VALIDATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        **Test Categories:**

        **A. Example Tests**
        ```python
        # From problem statement
        assert algorithm(example_input_1) == example_output_1
        assert algorithm(example_input_2) == example_output_2
        ```

        **B. Basic Functionality**
        ```python
        # Normal cases
        assert sort([3,1,2]) == [1,2,3]
        assert search([1,2,3], 2) == 1
        ```

        **C. Edge Cases**
        ```python
        # Empty
        assert algorithm([]) == expected_empty

        # Single element
        assert algorithm([1]) == expected_single

        # Two elements
        assert algorithm([1,2]) == expected_two

        # All same
        assert algorithm([5,5,5]) == expected_same

        # Minimum values
        assert algorithm(min_input) == min_output

        # Maximum values
        assert algorithm(max_input) == max_output
        ```

        **D. Boundary Conditions**
        ```python
        # Integer overflow
        assert algorithm([2**31-1]) handles_large_int

        # Negative numbers
        assert algorithm([-1,-2,-3]) == expected_negative

        # Zero
        assert algorithm([0,0,0]) == expected_zeros
        ```

        **E. Special Cases**
        ```python
        # Duplicates
        assert algorithm([1,2,2,3]) handles_duplicates

        # Already sorted
        assert algorithm([1,2,3,4]) == [1,2,3,4]

        # Reverse sorted
        assert algorithm([4,3,2,1]) == [1,2,3,4]
        ```

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        PHASE 2: COMPLEXITY VALIDATION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        **A. Theoretical Analysis**
        - Calculate time complexity
        - Calculate space complexity
        - Compare with requirements

        **B. Empirical Verification**
        ```python
        import time

        sizes = [100, 1000, 10000, 100000]
        times = []

        for n in sizes:
            data = generate_test_data(n)
            start = time.time()
            algorithm(data)
            times.append(time.time() - start)

        # For O(n log n), should see linear growth with small log factor
        # For O(nÂ²), doubling n should ~4x time
        for i in range(1, len(times)):
            ratio = times[i] / times[i-1]
            size_ratio = sizes[i] / sizes[i-1]
            print(f"Size {sizes[i]}: time ratio = {ratio:.2f}")
        ```

        **C. Complexity Verification**
        - Does measured complexity match theoretical?
        - Is it acceptable for constraints?

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        PHASE 3: STRESS TESTING
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        **A. Random Testing**
        ```python
        import random

        def stress_test(iterations=1000):
            for i in range(iterations):
                n = random.randint(1, 1000)
                data = [random.randint(-10**9, 10**9) for _ in range(n)]

                result = algorithm(data)

                # Verify properties
                assert len(result) == expected_length(data)
                assert is_valid_result(result)

                if i % 100 == 0:
                    print(f"Passed {i} random tests")

            print("âœ… All random tests passed!")
        ```

        **B. Worst-Case Testing**
        ```python
        # Test worst-case input
        worst_case = generate_worst_case(10000)
        result = algorithm(worst_case)
        assert is_correct(result)
        ```

        **C. Maximum Constraint Testing**
        ```python
        # Test at maximum constraints
        max_n = 100000  # from problem
        max_data = generate_max_input(max_n)

        import time
        start = time.time()
        result = algorithm(max_data)
        elapsed = time.time() - start

        assert elapsed < time_limit  # Usually 1-2 seconds
        assert is_correct(result)
        ```

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        PHASE 4: PROPERTY-BASED TESTING
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        **Verify Algorithm Properties:**

        **For Sorting:**
        ```python
        def verify_sort(original, sorted_result):
            # Property 1: Same length
            assert len(original) == len(sorted_result)

            # Property 2: Same elements (multiset equality)
            assert sorted(original) == sorted(sorted_result)

            # Property 3: Is sorted
            for i in range(len(sorted_result) - 1):
                assert sorted_result[i] <= sorted_result[i+1]

            # Property 4: Stability (if required)
            # ...
        ```

        **For Graph Algorithms:**
        ```python
        def verify_shortest_path(graph, path, start, end):
            # Property 1: Path connects start to end
            assert path[0] == start and path[-1] == end

            # Property 2: Consecutive nodes are connected
            for i in range(len(path) - 1):
                assert graph.has_edge(path[i], path[i+1])

            # Property 3: Path length is minimal
            # Compare with BFS result
        ```

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        VALIDATION REPORT FORMAT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        ```
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ALGORITHM VALIDATION REPORT
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Algorithm: Merge Sort
        Date: 2024-01-15

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        âœ… CORRECTNESS VALIDATION: PASSED
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Example Tests:       5/5 âœ…
        Basic Tests:        10/10 âœ…
        Edge Cases:          8/8 âœ…
        Boundary Conditions: 6/6 âœ…
        Special Cases:       4/4 âœ…

        Total: 33/33 tests passed

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        âœ… COMPLEXITY VALIDATION: PASSED
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Theoretical Complexity:
        - Time: O(n log n)
        - Space: O(n)

        Empirical Verification:
        n=100     â†’ 0.12 ms
        n=1,000   â†’ 1.45 ms   (ratio: 12.1x, expected: ~10x)
        n=10,000  â†’ 17.3 ms   (ratio: 11.9x, expected: ~10x)
        n=100,000 â†’ 213 ms    (ratio: 12.3x, expected: ~10x)

        âœ… Matches O(n log n) complexity

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        âœ… STRESS TESTING: PASSED
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Random Tests: 1000/1000 âœ…
        Worst Case:   PASSED âœ…
        Max Constraint (n=100,000):
          - Time: 213 ms (limit: 1000 ms) âœ…
          - Memory: 1.2 MB (limit: 256 MB) âœ…

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        âœ… PROPERTY VALIDATION: PASSED
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        âœ… Output has same length as input
        âœ… Output contains same elements
        âœ… Output is correctly sorted
        âœ… Stable sort property maintained

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ğŸ¯ OVERALL RESULT: VALIDATED âœ…
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        The algorithm is:
        âœ… Correct - passes all test cases
        âœ… Efficient - meets complexity requirements
        âœ… Robust - handles edge cases
        âœ… Performant - runs within time/memory limits

        Ready for production/submission! ğŸš€

        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        ```

    on_success:
      end: true
    on_failure:
      end: true

settings:
  max_total_steps: 20
  timeout: 900  # 15 minutes

# Usage:
# aco workflow execute algorithm_validate --input "Validate my sorting algorithm"
# aco workflow execute algorithm_validate --input "Full validation before submission"
