# ReAct Pattern Configuration Template
# ReAct: Reasoning and Acting in a tight loop
# Pattern: Think → Act → Observe → Think → Act → Observe → ...

name: react
type: react
description: Reasoning and Acting pattern for iterative problem solving

# Pattern Overview
# The ReAct pattern combines reasoning with tool execution in an iterative loop.
# The agent thinks about what to do next, acts by calling tools, observes results,
# and repeats until the task is complete.

# When to Use ReAct
# - Debugging and troubleshooting
# - Code search and exploration
# - Log analysis and monitoring
# - Q&A about codebases
# - Iterative problem solving
# - Tasks with uncertain scope
# - When flexibility is more important than upfront planning

# Configuration
config:
  # Maximum number of think-act-observe cycles
  max_iterations: 10

  # Allow tool calling
  allow_tool_calling: true

  # Tools available to the agent
  # Choose tools appropriate for your task
  tools:
    - file_read
    - file_write
    - grep
    - shell_exec

  # LLM Configuration
  llm:
    temperature: 0.5  # Moderate creativity
    max_tokens: 2000  # Enough for reasoning + tool calls

# System Prompt Template
prompts:
  system: |
    You are a coding assistant using the ReAct (Reasoning and Acting) pattern.

    For each iteration:
    1. THOUGHT: Think about what information you need or what action to take next
    2. ACTION: Choose a tool and execute it with appropriate arguments
    3. OBSERVATION: Receive and analyze the tool result

    Continue this cycle until you have enough information to complete the task,
    then provide your final answer.

    Available tools: {tools}

    Guidelines:
    - Think step-by-step about what you need to accomplish
    - Use tools to gather information, not to guess
    - Each action should build on previous observations
    - Stop when you have a complete answer or solution
    - If stuck, try a different approach

# Example ReAct Cycle
example:
  task: "Find where the error 'connection refused' appears in the logs"

  iteration_1:
    thought: "I need to search for 'connection refused' in log files"
    action: "grep"
    args:
      pattern: "connection refused"
      glob: "logs/**/*.log"
    observation: "Found 3 matches in logs/server.log"

  iteration_2:
    thought: "Let me read the server log to see the context around these errors"
    action: "file_read"
    args:
      path: "logs/server.log"
    observation: "Log shows connection errors at 2025-01-15 10:30:15, seems to be database connection"

  iteration_3:
    thought: "I should check the database configuration"
    action: "file_read"
    args:
      path: "config/database.toml"
    observation: "Database host is set to localhost:5432"

  final_answer: |
    The "connection refused" error appears in logs/server.log at 2025-01-15 10:30:15.
    The application is trying to connect to a database at localhost:5432 but failing.
    This suggests the database server may not be running.

# Performance Characteristics
performance:
  speed: "fast"  # Quick iterations
  latency: "low"  # 1-5 LLM calls typically
  flexibility: "high"  # Can adapt to unexpected situations
  quality: "medium"  # Good for exploration, less structured

# Use Cases
use_cases:
  - name: "Exploratory debugging"
    description: "Finding bugs when you don't know where to start"
    typical_iterations: "5-8"

  - name: "Code search"
    description: "Finding code patterns or functions"
    typical_iterations: "2-4"

  - name: "Log analysis"
    description: "Investigating errors in logs"
    typical_iterations: "3-6"

  - name: "Interactive development"
    description: "Building features iteratively"
    typical_iterations: "8-12"

  - name: "Q&A about codebase"
    description: "Answering questions about code"
    typical_iterations: "2-5"

# Best Practices
best_practices:
  - "Start with broad searches, then narrow down"
  - "Read error messages carefully - they often tell you exactly what's wrong"
  - "Use grep to locate code, file_read to understand it"
  - "Don't repeat the same action if it didn't work - try something different"
  - "Build on previous observations rather than starting over"
  - "Stop when you have enough information, don't over-iterate"

# Common Pitfalls
pitfalls:
  - "Running out of iterations by repeating failed approaches"
  - "Not reading tool output carefully before next action"
  - "Using too many tools when simple approach would work"
  - "Not stopping when task is complete"

# Optimization Tips
optimization:
  - "Set max_iterations based on task complexity (simple: 5, complex: 15)"
  - "Use lower temperature (0.3-0.5) for more focused iterations"
  - "Limit tool set to only what's needed for the task"
  - "Provide clear task description in system prompt"

# Comparison with Other Patterns
vs_plan_execute: |
  ReAct is better when:
  - You don't know the full scope upfront
  - Exploration and discovery are important
  - Quick iterations are preferred over detailed planning

  Plan-Execute is better when:
  - Task requirements are clear and well-defined
  - Multiple dependent steps need coordination
  - Upfront planning saves time overall

vs_reflection: |
  ReAct is better when:
  - Speed is more important than perfection
  - Task is about finding information rather than creating it
  - First attempt usually works

  Reflection is better when:
  - Output quality is critical
  - Self-critique improves results
  - Perfectionism is valuable
